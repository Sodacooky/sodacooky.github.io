<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux 服务创建 （Systemd Service）</title>
    <link href="/2023/Linux_Systemd_Service/"/>
    <url>/2023/Linux_Systemd_Service/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是服务？有什么用？"><a href="#什么是服务？有什么用？" class="headerlink" title="什么是服务？有什么用？"></a>什么是服务？有什么用？</h1><p>Linux下面的服务可以理解为和Windows上的，也可以理解为一种守护(Daemon)进程，通常是在后台默默运行的基础设施应用，如数据库、驱动等。</p><p>通过创建服务，我们可以将自己的应用设为开机启动，并可以自动重启。</p><blockquote><p>本文参考了<a href="https://linuxhandbook.com/create-systemd-services/">How to create a systemd service in Linux</a>，基本上就是翻译了他。</p></blockquote><h1 id="服务配置文件-Systemd-Service-File"><a href="#服务配置文件-Systemd-Service-File" class="headerlink" title="服务配置文件 (Systemd Service File)"></a>服务配置文件 (Systemd Service File)</h1><blockquote><p>Debian中以.service文件形式储存在&#x2F;etc&#x2F;systemd&#x2F;system中</p></blockquote><p>一个常见的服务配置文件如下，可见其由”Unit”、”Service”、”Install”三部分组成，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Apache web server<br><span class="hljs-attr">After</span>=network.target<br><span class="hljs-attr">Before</span>=nextcloud-web.service<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">ExecStart</span>=/usr/local/apache2/bin/httpd -D FOREGROUND -k start<br><span class="hljs-attr">ExecReload</span>=/usr/local/apache2/bin/httpd -k graceful<br><span class="hljs-attr">Type</span>=notify<br><span class="hljs-attr">Restart</span>=always<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=default.target<br><span class="hljs-attr">RequiredBy</span>=network.target<br></code></pre></td></tr></table></figure><h2 id="Unit-部分"><a href="#Unit-部分" class="headerlink" title="Unit 部分"></a>Unit 部分</h2><p>这部分记录了服务的基本信息，有以下常用部分：</p><ul><li>Description<br>  给人看的描述</li><li>Wants<br>  这个服务需要依赖与某个服务，如xxx.service。</li><li>Requires<br>  同上，但本项的服务如果依赖不存在或者失败则会不运行（也就是上面的Wants就是嘴上说说）。</li><li>After<br>  在什么阶段之后运行，通常是xxx.target，比如开启后运行就是<code>multi-user.target</code>，关机就是<code>poweroff.target</code>，要求有网络就是<code>network.target</code>等。</li><li>Before<br>  在什么服务之前运行，基本同上。</li></ul><h2 id="Service-部分"><a href="#Service-部分" class="headerlink" title="Service 部分"></a>Service 部分</h2><p>这部分记录了本服务应该如何运行，有以下常用部分：</p><ul><li>ExecStart<br>  这个服务运行程序的命令，比如执行一下apt更新就写<code>apt update</code></li><li>ExecReload<br>  少见。使用<code>systemctl restart</code>等命令时执行的重启命令，如果你的服务重启需要特定的命令，或者是一些操作储存数据的服务，你需要使用该项优雅地重启。</li><li>Type<br>  服务进程的类型，通常使用simple，当然还有exec、forking之类的。像nginx这种有一个短暂的中间父进程运营应用的，必须设置为forking否则systemd会认为运行失败。详见最后面的Type介绍节。</li><li>Restart<br>  少见。服务重启的时机，可以是关闭<code>no</code>或者几种异常情况<code>on-failure</code>、<code>on-abnormal</code>等。</li></ul><h2 id="Install-部分"><a href="#Install-部分" class="headerlink" title="Install 部分"></a>Install 部分</h2><p>这部分决定了使用<code>systemctl enable</code>和<code>systemctl disable</code>启动和关闭服务的处理，有以下常用部分：</p><ul><li>WantedBy<br>  和 Unit 段的 Wants 作用相似，填写的内容类似于Unit部分After和Before中的各种target，只有后面列出的不是服务所依赖的模块，而是依赖当前服务的模块，当前 Unit 激活时（enable）符号链接会放入 &#x2F;etc&#x2F;systemd&#x2F;system目录下面以&lt;Target名&gt;+.wants后缀构成的子目录中。</li><li>RequiredBy<br>  和 Unit 段的 Requires作用相似，同上，当前 Unit 激活时，符号链接会放入 &#x2F;etc&#x2F;systemd&#x2F;system目录下面以&lt;Target 名&gt;+.required后缀构成的子目录中。</li><li>Also<br>  当前 Unit enable&#x2F;disable 时，同时 enable&#x2F;disable 的其他 Unit。</li><li>Alias<br>  当前 Unit 可用于启动的别名。</li></ul><blockquote><p>WantedBy、RequiredBy：在 .wants&#x2F; 或 .requires&#x2F; 子目录中为服务建立相应的链接。这样做的效果是当列表中的服务启动，本服务也会启动。 </p></blockquote><blockquote><p>要实现开机启动，在Unit中写After或者在Install中写WantedBy都是可以的。</p></blockquote><h1 id="服务安装、运行"><a href="#服务安装、运行" class="headerlink" title="服务安装、运行"></a>服务安装、运行</h1><p>和Windows一样，服务的运行也是分用户的，Linux里的服务也分为Root用户运行和其他用户运行，区别只是服务配置文件的“存放”的位置。</p><p>Root用户运行的服务，配置讲上一章节写的xxx.service文件存放到<code>/etc/systemd/system/</code>，使用其他用户运行的服务，文件存放到<code>~/.config/systemd/user/</code>，你可能需要手动创建这个目录。</p><p>文件存放到位后，不重启系统则需要使用<code>systemctl daemon-reload</code>或<code>systemctl --user daemon-reload</code>刷新配置文件，后者是其他用户运行服务时使用的。</p><blockquote><p>后面安装、运行等非Root用户服务操作都添加<code>--user</code>参数</p></blockquote><p>直接<code>systemctl enable xxx.service</code>即可安装、启动，通过<code>is-enabled</code>可以查看是否被安装，然后就是常规的<code>start</code>、<code>stop</code>、<code>restart</code>命令，这里略过。</p><h1 id="服务运行类型-Service-Type"><a href="#服务运行类型-Service-Type" class="headerlink" title="服务运行类型 Service Type"></a>服务运行类型 Service Type</h1><p>在配置文件的<code>[Service]</code>部分中的Type，常用的几个简单介绍如下：</p><table><thead><tr><th align="left">Type</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">oneshot</td><td align="left">适合运行一次、短暂立刻退出的服务，可能需要同时设置 RemainAfterExit&#x3D;yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。</td></tr><tr><td align="left">simple</td><td align="left">立刻普通地启动程序。</td></tr><tr><td align="left">idle</td><td align="left">基本等于simple，但是等待其他服务启动、处理都完成了，相当于让位，也避免启动日志混在一起。</td></tr><tr><td align="left">notify</td><td align="left">基本等于simple，但在就绪后向systemd发送一个信号</td></tr><tr><td align="left">forking</td><td align="left">如果运行的程序有个短暂的中间父进程，或者说调用了fork()，父进程退出后应该视为正常，则使用此类型，应同时指定 PIDFile&#x3D;，以便 systemd 能够跟踪服务的主进程。</td></tr></tbody></table><blockquote><p>详细文档请看<a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html?ref=linuxhandbook.com#Options">该链接</a></p></blockquote><h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=nginx - high performance web server                                             <br><span class="hljs-comment">#描述服务</span><br><span class="hljs-attr">After</span>=network.target remote-fs.target nss-lookup.target                                     <br><span class="hljs-comment">#描述服务类别</span><br><br><span class="hljs-section">[Service]</span>                                <br><span class="hljs-attr">Type</span>=forking                                                                                 <br><span class="hljs-comment">#后台运行的形式</span><br><span class="hljs-attr">PIDFile</span>=/usr/local/nginx/logs/nginx.pid<br><span class="hljs-comment">#PID文件的路径</span><br><span class="hljs-attr">ExecStartPre</span>=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf<br><span class="hljs-comment">#启动前准备 校验配置文件是否错误</span><br><span class="hljs-attr">ExecStart</span>=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br><span class="hljs-comment">#启动命令 指定配置文件</span><br><span class="hljs-attr">ExecReload</span>=/usr/local/nginx/sbin/nginx -s reload<br><span class="hljs-comment">#重启命令</span><br><span class="hljs-attr">ExecStop</span>=/usr/local/nginx/sbin/nginx -s stop<br><span class="hljs-comment">#停止命令</span><br><span class="hljs-attr">ExecQuit</span>=/usr/local/nginx/sbin/nginx -s quit<br><span class="hljs-comment">#强制停止</span><br><span class="hljs-attr">PrivateTmp</span>=<span class="hljs-literal">true</span><br><span class="hljs-comment">#给服务分配临时空间</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="开机时运行一个脚本"><a href="#开机时运行一个脚本" class="headerlink" title="开机时运行一个脚本"></a>开机时运行一个脚本</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span> = Run script after system booted.<br><span class="hljs-comment"># 要求脚本具有可执行权限</span><br><span class="hljs-attr">ConditionFileIsExecutable</span>=/usr/bin/script.sh<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">ExecStart</span> = /usr/bin/script.sh<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span> = multi-user.target<br></code></pre></td></tr></table></figure><h1 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h1><p>推荐看看 <a href="https://www.junmajinlong.com/linux/index/#systemd">https://www.junmajinlong.com/linux/index/#systemd</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EVE Online 国服 ESI 登录方法记录</title>
    <link href="/2023/EVE_ESI/"/>
    <url>/2023/EVE_ESI/</url>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>通过<a href="https://esi.evepc.163.com/ui/#/">ESI</a>，我们可以利用HTTP请求的方式获取和改变游戏内的内容，也可以通过其OAuth2身份认证实现基于EVE账号的第三方登录，类似于你在某个非Github的网站使用Github账号登录。</p><h1 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h1><p>现在许多第三方登录方式的实现其实都是OAuth，全称是Open Authorization，一种开放授权协议，允许第三方应用程序使用资源所有者的凭据获得对资源有限访问权限。</p><p>使用场景比如，你自己写了一个Github代码仓库分析的网站，这固然需要Github代码仓库的内容，难道要用户自己从Github克隆到电脑上然后又上传给你的网站？这太麻烦了。使用Github提供的OAuth，并且索要仓库的访问、修改权限（Github的话默认给了），在登录你的网站时通过Github账号登录，你的网站就有了访问该用户Github仓库的能力。</p><p>也可以看看某百科的例子：</p><blockquote><p>如果一个用户需要两项服务：一项服务是图片在线存储服务A，另一个是图片在线打印服务B。由于服务A与服务B是由两家不同的服务提供商提供的，所以用户在这两家服务提供商的网站上各自注册了两个用户，假设这两个用户名各不相同，密码也各不相同。当用户要使用服务B打印存储在服务A上的图片时，用户该如何处理。方法一：用户可能先将待打印的图片从服务A上下载下来并上传到服务B上打印，这种方式安全但处理比较繁琐，效率低下；方法二：用户将在服务A上注册的用户名与密码提供给服务B，服务B使用用户的帐号再去服务A处下载待打印的图片，这种方式效率是提高了，但是安全性大大降低了，服务B可以使用用户的用户名与密码去服务A上查看甚至篡改用户的资源。OAuth就可以实现在服务B上使用服务A的账号密码登录（账号密码判断也是由A进行），用户确认后服务B就可以访问服务A里的照片。</p></blockquote><p>OAuth的具体概念和使用方法、四种授权模式别人的文章写得很清楚，暂时无法超越，故请读者自行学习。（后面会填坑）</p><h1 id="EVE-ESI-认证"><a href="#EVE-ESI-认证" class="headerlink" title="EVE ESI 认证"></a>EVE ESI 认证</h1><p>网易官方没有放出申请OAuth接口（申请Application，以获得client_id和client_secret）的地方，但是击杀榜网站和商人助手等依旧能够调用ESI，原因是网易的ESI(EVE Swagger Interface网页)其实也是一个Application，他的client_id为bc90aa496a404724a93f41b4f4e97761，用它就行。</p><h2 id="Implicit模式"><a href="#Implicit模式" class="headerlink" title="Implicit模式"></a>Implicit模式</h2><blockquote><p>隐式授权是为了兼顾到在浏览器中用诸如JavaScript的脚本语言实现的客户端而优化的简化授权代码流程。在隐式授权流程中，不是发给客户端一个授权码，而是直接发给客户端一个访问令牌，而且不会对客户端进行认证。隐式授权提高了一些客户端（比如基于浏览器实现的客户端）的响应能力和效率，因为它减少了获得访问令牌所需的往返次数。</p></blockquote><p>使用Implicit模式通过认证直接获取到access_token，但是这个Token通常只有20分钟的有效期。</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>需要<strong>用户在浏览器中</strong>打开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET https://login.evepc.163.com/v2/oauth/authorize<br></code></pre></td></tr></table></figure><p>并携带Query参数：</p><table><thead><tr><th align="left">参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">response_type</td><td align="left">必填，授权模式，隐式授权填token</td></tr><tr><td align="left">client_id</td><td align="left">必填，OAuth的客户端ID，此处填官方的bc90aa496a404724a93f41b4f4e97761</td></tr><tr><td align="left">redirect_uri</td><td align="left">必填，表示授权成功后跳转并携带Token的URI，这里只能填<a href="https://esi.evepc.163.com/ui/oauth2-redirect.html">https://esi.evepc.163.com/ui/oauth2-redirect.html</a></td></tr><tr><td align="left">state</td><td align="left">必填，表示客户端的当前状态，可以指定任意值，授权成功后将原样返回用以校验</td></tr><tr><td align="left">scope</td><td align="left">选填但不填没意义，表示申请的权限范围，不可超过4项，权限具体权限见后文</td></tr><tr><td align="left">realm</td><td align="left">必填，不知道干嘛的，随便写点什么</td></tr><tr><td align="left">device_id</td><td align="left">同上</td></tr></tbody></table><p>上一步的请求执行后会跳转到网易账号的登录网页，登录完成后会选择EVE角色，选择完成后会跳转到设置的redirect_uri，并且地址栏中带有Token，这个URI长这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>esi.evepc.<span class="hljs-number">163</span>.com<span class="hljs-regexp">/ui/</span>oauth2-redirect.html<span class="hljs-comment">#access_token=&#123;你要的Token&#125;&amp;expires_in=&#123;过期时间&#125;&amp;state=&#123;原样返回的状态码&#125;</span><br></code></pre></td></tr></table></figure><p>Token中的参数如下：</p><table><thead><tr><th align="left">参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">权限令牌，使用它可以读取所选游戏人物对应的私密内容</td></tr><tr><td align="left">expires_in</td><td align="left">过期时间，单位为秒，一般为20分钟</td></tr><tr><td align="left">state</td><td align="left">将上面请求的state原封不动返回</td></tr></tbody></table><p>你只需要让用户复制浏览器中地址栏这段URI，然后分析提取出AccessToken即可。</p><h2 id="Authorization模式"><a href="#Authorization模式" class="headerlink" title="Authorization模式"></a>Authorization模式</h2><blockquote><p>授权码是授权服务器用来获取并作为客户端和资源所有者之间的中介。代替直接向资源所有者请求授权，客户端定向资源所有者到一个授权服务器，授权服务器反过来指导资源所有者将授权码返回给客户端。在将授权码返回给客户端之前，授权服务器对资源所有者进行身份验证并获得授权。因为资源所有者只对授权服务器进行身份验证，所以资源所有者的凭据永远不会与客户机共享。</p></blockquote><p>流程比较复杂，但是因为拿到了refresh_token可以永久获取access_token（但refresh_token泄露等于密码泄露，只能用户去官网解除授权）。</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>需要<strong>用户在浏览器中</strong>打开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET https://login.evepc.163.com/v2/oauth/authorize<br></code></pre></td></tr></table></figure><p>并携带Query参数：</p><table><thead><tr><th align="left">参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">response_type</td><td align="left">必填，授权模式，授权码模式填code</td></tr><tr><td align="left">client_id</td><td align="left">必填，OAuth的客户端ID，此处填官方的bc90aa496a404724a93f41b4f4e97761</td></tr><tr><td align="left">redirect_uri</td><td align="left">必填，表示授权成功后跳转并携带Token的URI，这里只能填<a href="https://esi.evepc.163.com/ui/oauth2-redirect.html">https://esi.evepc.163.com/ui/oauth2-redirect.html</a></td></tr><tr><td align="left">state</td><td align="left">必填，表示客户端的当前状态，可以指定任意值，授权成功后将原样返回用以校验</td></tr><tr><td align="left">scope</td><td align="left">选填但不填没意义，表示申请的权限范围，不可超过4项，权限具体权限见后文</td></tr><tr><td align="left">realm</td><td align="left">必填，不知道干嘛的，随便写点什么</td></tr><tr><td align="left">device_id</td><td align="left">同上</td></tr></tbody></table><blockquote><p>和Implicit模式只有response_type不同</p></blockquote><p>同Implicit模式，选择完成后会跳转到设置的redirect_uri，并带以下参数：</p><table><thead><tr><th align="left">参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">表示授权码、有效期应该很短，通常为10分钟，且只能使用该码一次</td></tr><tr><td align="left">state</td><td align="left">将上面请求的state原封不动返回</td></tr></tbody></table><p>URI长这样：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pf">https://esi.evepc.<span class="hljs-number">163</span>.com/ui/oauth2-redirect.html?code=&#123;授权码&#125;&amp;<span class="hljs-keyword">state</span>=&#123;原样返回的状态码&#125;<br></code></pre></td></tr></table></figure><p>从URI拿到code，进入下一步。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>在自己的应用，随便用什么请求工具，发送一个POST请求到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST https://login.evepc.163.com/v2/oauth/token<br></code></pre></td></tr></table></figure><p>并在请求Body中以<code>x-www-form-urlencoded</code>形式传递以下参数：</p><table><thead><tr><th align="left">参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">必填，表示获取类型，此处的值为authorization_code</td></tr><tr><td align="left">client_id</td><td align="left">必填，还是那个ID</td></tr><tr><td align="left">redirect_uri</td><td align="left">必填，还是那个URI</td></tr><tr><td align="left">code</td><td align="left">必填，上一步获取到的code，授权码</td></tr></tbody></table><blockquote><p>其他Body格式没尝试过</p></blockquote><p>会响应<code>application/json; charset=utf-8</code>，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxx&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;expires_in&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1199</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bearer&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">access_token</td><td align="left">和隐式模式相同的只有20分钟的Token</td></tr><tr><td align="left">expires_in</td><td align="left">过期时间，通常是20分钟</td></tr><tr><td align="left">refresh_token</td><td align="left">一个永久有效的、用于重新获取access_token的token</td></tr></tbody></table><h3 id="获取-刷新access-token"><a href="#获取-刷新access-token" class="headerlink" title="获取&#x2F;刷新access_token"></a>获取&#x2F;刷新access_token</h3><p>第二步中拿到的access_token仍然是会过期的，关键是储存好refresh_token，在用户使用时用它重复获取access_token。</p><p>步骤类似第二步，在自己的应用发送一个POST请求到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">POST https://login.evepc.163.com/v2/oauth/token<br></code></pre></td></tr></table></figure><p>并在请求Body中以<code>x-www-form-urlencoded</code>形式传递以下参数：</p><table><thead><tr><th align="left">参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">grant_type</td><td align="left">必填，表示获取类型，此处的值为refresh_token</td></tr><tr><td align="left">client_id</td><td align="left">必填，还是那个ID</td></tr><tr><td align="left">refresh_token</td><td align="left">必填，上一步获取到的refresh_token</td></tr></tbody></table><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><blockquote><p>不是所有东西都能通过ESI获取的</p></blockquote><ol><li>钱包：包括转账记录、交易记录（没错，就是空间站右键交易）、余额、市场买卖、忠诚点等<ul><li>授权项目例子：esi-wallet.read_character_wallet.v1、esi-wallet.read_character_wallet.v1、esi-characters.read_loyalty.v1</li><li>无法读取的有：LP消费记录、LP收益来源（可以通过消息列表间接查询到2022.11.4注）</li></ul></li><li>玩家实况：包括驾驶的船只、所在地点、登录情况等<ul><li>授权项目例子：esi-location.read_location.v1、esi-location.read_ship_type.v1、esi-corporations.track_members.v1</li><li>无法读取的有：开火记录、货柜内容、拾取记录</li></ul></li><li>建筑：包括建筑地点、燃料耗尽时间、增强情况、增强时间、服务类型与上线情况、解锚时间（精确到秒）等<ul><li>授权项目例子：esi-corporations.read_structures.v1（需要军团对应权限）</li><li>无法读取的有：燃料剩余数目、装备情况、建筑内人数、移动式仓库</li></ul></li><li>私人机密：包括邮件（收、发、具体内容）、个人位标、资产、克隆、合同、联系人、种菜地址、工业制造情况等<ul><li>授权项目例子：esi-bookmarks.read_character_bookmarks.v1、esi-assets.read_assets.v1</li><li>无法读取的有：聊天框、笔记本</li></ul></li><li>舰队：包括舰队拉人、踢人、增减中队、设置舰队广告、舰队人员移动<ul><li>授权项目例子：esi-fleets.write_fleet.v1、esi-fleets.read_fleet</li><li>无法实现的有：创建舰队、解散舰队（当然，踢走所有人也不是不可以）</li></ul></li></ol><p>最多一次同时申请四个权限，使用空格连接并URL编码填到上面的scope中，更多的权限可以访问<a href="https://esi.evepc.163.com/ui/#/">官方ESI</a>查看右上角Authorize中的，Swagger中也给接口标注了需要的权限。</p><h1 id="EVE-ESI-退出-解绑"><a href="#EVE-ESI-退出-解绑" class="headerlink" title="EVE ESI 退出&#x2F;解绑"></a>EVE ESI 退出&#x2F;解绑</h1><p>当用户不想继续使用ESI，被ESI获取数据，就需要解绑。</p><ul><li>中立做法</li></ul><p>refresh_token理论上，约1个月不使用，会被服务器清理。</p><ul><li>用户做法</li></ul><p>EVE官网右上角“ESI解除授权”。</p><ul><li>其他做法</li></ul><p>据说可以通过OAuth的revoke，或者访问<code>https://login.evepc.163.com/account/logoff</code>或<code>https://login.evepc.163.com/account/logoff?returnUrl=https%3A%2F%2Flogin.evepc.163.com%2Faccount%2Flogoff</code>来解绑，看起来比较麻烦。</p><h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><p>参考了部分【虫洞深度自然神秘探索者】中的文章，<a href="http://wdnmd.biz/%E8%90%8C%E6%96%B0%E5%AD%A6%E9%99%A2;%E6%94%BB%E7%95%A5%E6%95%99%E7%A8%8B;esi%E4%B8%93%E8%AE%BA">原文地址</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EVE</tag>
      
      <tag>OAuth2</tag>
      
      <tag>SSO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud笔记 （Netflix）</title>
    <link href="/2023/SpringCloud/"/>
    <url>/2023/SpringCloud/</url>
    
    <content type="html"><![CDATA[<h1 id="微服务与SpringCloud"><a href="#微服务与SpringCloud" class="headerlink" title="微服务与SpringCloud"></a>微服务与SpringCloud</h1><p>为了降低大型WEB应用复杂性，以及应对越来越高的并发要求，微服务出现了（大嘘）。</p><p>可以简单理解为，就是将一个大的应用，拆分成多个小的模块，每个模块都有自己的功能和职责，模块之间可以进行交互。</p><p>SpringCloud是一套微服务解决方案，包含数个组件，而这些组件或者说SpringCloud的方案最早来自于Netflix（就是你看不到的那个网飞），而现如今Netflix很多组件已经不再开源更新，就有了SpringCloudAlibaba这种新方案，有不同的组件搭配。</p><p>常见的组件有：</p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">服务的注册和发现</td><td align="center">Eureka, Nacos, consul</td></tr><tr><td align="center">服务的负载均衡</td><td align="center">Ribbon, Dubbo</td></tr><tr><td align="center">服务的相互调用</td><td align="center">OpenFeign, Dubbo</td></tr><tr><td align="center">服务的容错</td><td align="center">Hystrix, Sentinel</td></tr><tr><td align="center">服务网关</td><td align="center">SpringCloud Gateway, Zuul</td></tr><tr><td align="center">服务配置的统一管理</td><td align="center">Config-server, Nacos, Apollo</td></tr><tr><td align="center">服务消息总线</td><td align="center">Bus</td></tr><tr><td align="center">服务安全组件</td><td align="center">Spring Security, Oauth2.0</td></tr></tbody></table><p>而常见的实现方案有：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">Dubbo+Zookeeper     老东西<br>SpringCloud Netflix 经典原味<br>SpringCloud Alibaba 更好的选择<br></code></pre></td></tr></table></figure><blockquote><p>目前完成了SpringCloud Netflix的部分，并将某些组件更换为更现代化的，如网关使用Gateway和更新的OpenFeign。SpringCloud Alibaba正在路上，待我用目前的组件完成毕设再来写。</p></blockquote><h1 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h1><p>Eureka作为服务注册与发现的组件和其他Netflix公司的服务组件一起，被Spring Cloud社区整合为Spring Cloud Netflix模块。</p><blockquote><p>Eureka不再开源更新！所以采用SpringCloud Netflix并不是一个好的选择！</p></blockquote><h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><p>指的是在一个分布式系统中：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">一致性（Consistency）<br>    多个节点里的数据需要是一致的<br>可用性（Availability）<br>    如果<span class="hljs-literal">Master</span>(主从模式？)挂了，那么应该选一个新的<span class="hljs-literal">Master</span>继续维持对外服务<br>分区容错性（Partition tolerance）<br>    网络与地理分布造成各节点数据的不同步需要被解决<br></code></pre></td></tr></table></figure><p>这三个要素最多只能同时实现两点，不可能三者兼顾，而分区容错性必须存在——即CP&#x2F;AP二选一，Eureka为AP。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>创建SpringCloud项目仍然使用Spring Initializr。</p><p>Eureka服务器只需要添加Eureka Server，Eureka客户端则需要Eureka Discovery Client。</p><blockquote><p>SpringCloud某个版本往往只能使用某几个版本的SpringBoot和各种组件，但你通常无需在意。</p></blockquote><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>在启动类前添加注解<code>@EnableEurekaServer</code>才会启用Eureka服务器，这时候只要启动这个SpringBoot项目就会运行起来EurekaServer。（这个服务端抱着SpringBoot大腿跑，不用另外配置部署）</p><p>在SpringBoot的配置文件中，你至少需要配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span> <span class="hljs-comment">#通常约定Eureka服务器端口是8761</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment">#自定义服务名称</span><br>        <span class="hljs-comment">#在SpringCloud时代，你需要为应用指定一个名称，你才能找到他</span><br>        <span class="hljs-comment">#多个相同名称（通常也是相同项目）应用将会共同服务（前提是有负载均衡）</span><br></code></pre></td></tr></table></figure><p>这个时候浏览器访问<a href="http://localhost:8761就可以进入Eureka的信息网页。">http://localhost:8761就可以进入Eureka的信息网页。</a></p><blockquote><p>Eureka服务端既是一个提供注册功能的服务端，也可以作为客户端注册到别的Eureka服务端，默认开启并会自己注册自己，后面将利用这个功能形成Eureka集群。</p></blockquote><p>服务端常用额外配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#个人觉得没有必要配置这些</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#是否拉取服务列表</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#是否注册自己（单机 eureka 一般关闭注册自己,集群注意打开）</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">30000</span> <span class="hljs-comment">#清除无效节点的频率(毫秒)--定期删除</span><br>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#server 的自我保护机制，避免因为网络原因造成误剔除,生产环境建议打开</span><br>    <span class="hljs-attr">renewal-percent-threshold:</span> <span class="hljs-number">0.85</span> <span class="hljs-comment">#15 分钟内有 85%的 client 没有续约，那么则可能是自己出问题了，不剔除他们</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment"># 服务主机名称</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;eureka.instance.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span> <span class="hljs-comment"># 实例 id</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># (管理页面)服务列表以 ip 的形式展示</span><br>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 表示Client发送心跳给Server端的频率</span><br>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">20</span> <span class="hljs-comment">#表示Server收到Client心跳的超时时间</span><br></code></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>在启动类前添加注解<code>@EnableDiscoveryClient</code>才会启动Eureka客户端，老版本为<code>@EnableEurekaClient</code>，建议使用前者。</p><p>类似地至少需要配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#服务的端口</span><br>  <span class="hljs-comment">#注意不要与Eureka服务端端口概念混淆，服务端配置的注册中心的端口，而此处是Web服务端口</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-client-114514</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka</span> <span class="hljs-comment">#注册中心的地址，注意/eureka和你的实际端口</span><br>      <span class="hljs-comment">#defaultZone是大小写敏感的MagicString，实际上内容就是http://localhost:8761/eureka，一个默认的值</span><br></code></pre></td></tr></table></figure><p>常用额外配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#拉取服务列表</span><br>    <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 表示 eureka-client 间隔多久去拉取服务注册信息</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;eureka.instance.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>客户端定期向注册中心发送心跳证明自己存活，也获取一份服务列表以便于调用其他服务。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>要建立Eureka集群，需要将Eureka服务器放在不同的机器上，然后在任一服务器节点的配置文件<code>eureka.client.service-url</code>中添加其他所有节点，形成一个两两连接的网络。</p><p>配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 192.168.0.1</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://192.168.0.2/eureka,</span> <span class="hljs-string">http://192.168.0.3/eureka....</span><br><span class="hljs-comment"># 192.168.0.2</span><br><span class="hljs-string">...</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://192.168.0.1/eureka,</span> <span class="hljs-string">http://192.168.0.3/eureka....</span><br><span class="hljs-comment"># ....</span><br></code></pre></td></tr></table></figure><blockquote><p>在单一机器上改变端口配合hosts文件修改也可以实现，但是这没有多大意义</p></blockquote><p>客户端，则在<code>eureka.client.service-url</code>中添加所有节点。</p><p>Eureka集群没有主机和从机的概念，节点都是对等的，集群中的服务端会交换服务列表，且只有集群里面有一个节点存活，就能保证服务的可用性。</p><h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><p>需要在SpringBoot配置文件中，把可能需要改变的参数写成EL表达式，像：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;PORT:8761&#125;</span><br><span class="hljs-comment"># PORT是外部注入的变量，8761是默认值</span><br></code></pre></td></tr></table></figure><p>要注入变量，只需要运行Docker时添加<code>-e PORT=11451</code>。</p><h1 id="Netflix-Ribbon"><a href="#Netflix-Ribbon" class="headerlink" title="Netflix Ribbon"></a>Netflix Ribbon</h1><p>Ribbon 是一个基于 HTTP 和 TCP 的客户端负载均衡工具，Ribbon可以和RestTemplate结合使用，RestTemplate类似于OkHttp之类的Http请求库，但更常用的是和OpenFeign一起使用并且被OpenFeign集成，故Ribbon可以不怎么看。</p><p>通过RestTemplate使用Ribbon，只需要引入Ribbon，然后在创建RestTemplate的Bean方发出加上@LoadBanlanced，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title function_">restTemplate</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();&#125;<br></code></pre></td></tr></table></figure><p>然后在需要调用其他服务的地方注入，然后访问<code>http://服务名称//....</code>即可，因为Ribbon已经通过注册中心拿到了服务列表，因此你只需要给服务名称。</p><blockquote><p>服务名称就是 spring.application.name</p></blockquote><h1 id="OpenFeign-Netflix-Feign-Plus"><a href="#OpenFeign-Netflix-Feign-Plus" class="headerlink" title="OpenFeign (Netflix Feign Plus)"></a>OpenFeign (Netflix Feign Plus)</h1><p>Feign 是声明性(注解)Web 服务客户端，个人理解就是通过注册中心自己找服务简化Http调用。</p><p>Feign是Netflix公司的且不在开源更新，而OpenFeign是SpringCloud搞出来的，在Feign的基础上支持了SpringMVC的注解等各种改进，现在说到Feign通常都是OpenFeign。</p><h2 id="服务提供者（被调用者）"><a href="#服务提供者（被调用者）" class="headerlink" title="服务提供者（被调用者）"></a>服务提供者（被调用者）</h2><p>被调用者不需要什么额外的依赖，什么也不需要改动，只需要保证自己在注册中心注册了，并且有Web接口即可。</p><h2 id="服务使用者（调用者）"><a href="#服务使用者（调用者）" class="headerlink" title="服务使用者（调用者）"></a>服务使用者（调用者）</h2><p>需要引入OpenFeign依赖（当然也需要注册中心），Spring Initializr里面就有。</p><p>然后在<strong>启动类</strong>上启用Feign客户端，添加注解@EnableFeignClients。</p><p>并且创建<strong>接口</strong>（建议放到feign包），添加@FeignClient注解，其value为服务处提供者的服务名称。</p><p>最后，将服务提供者Web接口的签名复制粘贴，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> xxx.xxxxx.feign;<br><br><span class="hljs-meta">@FeignClient(value = &quot;other-service-name&quot;)</span> <span class="hljs-comment">//你知道吗，value可以省略哦</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceFeign</span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;api&quot;)</span><br>    String <span class="hljs-title function_">doApi</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用只需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestMapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller</span>&#123; <span class="hljs-comment">//current-serivce</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ServiceFeign serviceFeign;<br>    <span class="hljs-meta">@GetMapping(&quot;apif&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doApiFeign</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> serviceFeign.doApi();        <br>    &#125;<br>    <span class="hljs-comment">//用户-&gt;current-service.doApiFeign()-&gt;Feign,Ribbon,RPC-&gt;other-serivce-name.doApi()</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>库底层通过为接口创建代理类实现，类似于装饰器之类的设计模式。</p></blockquote><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>在Feign中想要传递参数，接口的@PathVariable、@RequestParam、@RequestBody等都不能省略，建议控制器本身和Feign接口均不省略且保持一致（包括require等参数）（这应该是规范一部分）。</p><p>通过Feign远程调用传递时间参数时，如Date对象，可能遇到时区不一致问题，可能直接换算时区过来也不正确，会出错是因为旧版本OpenFeign还在使用new Date(date.toString())这种有问题的方法，新版本POST请求@RequestBody传Date对象实测没有问题，如果你还在使用旧版本可以考虑：</p><ol><li>将传递Date对象变为传递序列化后的字符串，接收方再反序列化。</li><li>使用JDK8的LocalDate（日期）或LocalDateTime（精度到秒的日期）对象。</li><li>魔改Feign。</li></ol><h2 id="更换连接组件"><a href="#更换连接组件" class="headerlink" title="更换连接组件"></a>更换连接组件</h2><p>OpenFeign或者说Ribbon默认使用HttpURLConnection实现，如果传参有Body则会强制转为Post，这将导致MethodNotAllowed，要解决可以选择放弃传递Body的Get请求或使用其他请求组件。</p><blockquote><p>但使用其他请求会遇到很多问题配置可能比较复杂，这里不记录我自己也不用，等到遇到性能瓶颈不得不改时会更新这个部分。</p></blockquote><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>如果通过Feign调用服务，被调用方长时间处理，可能会导致超时，进而调用方向用户报500错误。</p><p>因为OpenFeign底层使用Ribbon，因此调节超时时间应该通过Ribbon配置调节：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#ms，调用超时，连接上了调用时的超时时间</span><br>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">3000</span> <span class="hljs-comment">#ms，连接的超时时间，用来解决服务启动时间差等问题</span><br><span class="hljs-comment">#这些在源代码注释里面找，并且不同版本的默认值可能不同！</span><br></code></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Feign 提供了日志打印功能，我们可以通过配置来调整日志级别。</p><p>开启日志，需要通过配置类配置日志打印级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    Logger.Level <span class="hljs-title function_">feignLogger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.FULL<br>    &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">NONE 默认的，不显示日志</span><br><span class="hljs-comment">BASE 仅记录请求方法，URL ，响应状态码及执行时间</span><br><span class="hljs-comment">HEADERS 在 BASE 之上增加了请求和响应头的信息</span><br><span class="hljs-comment">FULL 在 HEADERS 之上增加了请求和响应的正文及无数</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>然后对你的Feign接口启用debug级别日志：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">xxx.xxxx.feign:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h1 id="Netflix-Hystrix"><a href="#Netflix-Hystrix" class="headerlink" title="Netflix Hystrix"></a>Netflix Hystrix</h1><h2 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">用户 -&gt; 服务A -&gt; 服务B -&gt; 服务C<br></code></pre></td></tr></table></figure><p>如上所示的链式服务调用（依赖）中，服务提供者C因为某种原因出现故障，那么服务调用者服务B依赖于服务C的请求便无法成功调用其提供的接口，依赖于服务C的请求越来越多导致服务B的服务器或Web容器资源耗尽，造成服务B线程阻塞，导致服务B也出现故障。紧接着，服务A依赖于服务B，由于服务B也出现了故障导致服务A出现故障。以此类推引起整个链路中的所有微服务都不可用。</p><p>通常的解决办法有：</p><ul><li>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待</li><li>线程隔离：限定每个业务能使用的线程数，避免耗尽整个Web容器的资源，因此也叫线程隔离。</li><li>熔断降级：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。 </li><li>流量控制：制业务访问的QPS，避免服务因流量的突增而故障。</li></ul><p>在分布式链路中，只要有一个服务不可用，都会导致整个业务或者链路瘫痪！</p><p>服务雪崩的本质是线程没有及时回收。</p><p>Hystrix是一个熔断器、断路器，保护服务不产生服务雪崩。</p><blockquote><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。</p></blockquote><h2 id="使用Hystrix"><a href="#使用Hystrix" class="headerlink" title="使用Hystrix"></a>使用Hystrix</h2><p>Hystrix常与OpenFeign、Ribbon一起使用，因为有服务调用才会有服务雪崩的发生，Hystrix才能隔离服务的访问点阻止联动故障。</p><p>服务提供者依旧无需改动，除非他也要调用其他服务。</p><p>添加Hystrix依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-hystrix --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>你可能需要去掉version，也可能需要version，在我这（阿里镜像）不加version无法添加依赖。</p></blockquote><blockquote><p>某些版本的SpringCloud，可在Initializr里的SpringCloud CircuitBreaker下找到Hystrix，但我的3.0版本只有一个Resilience4J。</p></blockquote><p>然后，在配置文件中开启：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>实测新版本没有了这个配置，也不在spring.cloud.openfeign下。翻阅其他文档得知，是在启动类上添加@EnableCircuitBreaker注解，也可以尝试用@SpringCloudApplication和@EnableHystrix。</p></blockquote><p>在网上搜索文档的时候看到很多使用@HystrixCommand注解并配合RestTemplate使用的文章，但我看的文档使用OpenFeign时写法并不相同，但流程大同小异，因此想看的自行搜索。</p><p>要提供熔断机制，或者说熔断后的降级、替代措施，需要一个实现Feign接口的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//需要让Spring托管</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceHystrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderServiceFeign</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doApi</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我是备胎&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这时候@Autowired注入OrderServiceFeign时，会有冲突，因为存在Feign的代理类和上面这个类，你可以使用@Resource或者添加@Qualified</p></blockquote><p>同时，在原Feign接口的@FeignClient中添加fallback类，指定为我们实现的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;provider-service&quot;, fallback = OrderServiceHystrix.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderServiceFeign</span>&#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doApi</span><span class="hljs-params">()</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Hystrix本质类似于AOP切入了服务调用请求的过程，在开始前判断断路器开关，在结束后判断是否要更新断路器状态，相当于用了@Around。而断路器是决定调用请求进Fallback还是正常访问一个拦截机制。</p><p>断路器状态通常有关，开，半开。当为关是不拦截服务调用；当一定时间内调用失败次数达到阈值断路器将会打开，请求将进入Fallback（熔断了）；当断路器打开是会让少许请求尝试调用服务，如果成功那么断路器将关闭，此时业务恢复正常。</p><h1 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h1><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的服务节点调用来协同产生最后的请求结果，每一个请求都会开成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引导起整个请求最后的失败。因此我们需要一些链路跟踪监控工具来监控我们的微服务，链路追踪指的是追踪微服务的调用路径。</p><blockquote><p>不建议微服务中链路调用超过3次。</p></blockquote><p>Sleuth是Spring Cloud提供的分布式系统服务链追踪组件，它大量借用了Google的Dapper，Twitter的Zipkin。</p><p>通常的方案是Sleuth+Zipkin，Zipkin 是 Twitter 的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口。该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。</p><blockquote><p>Sleuth是一个上报工具，而Zipkin是一个处理和展示Sleuth所上报信息的工具。</p></blockquote><h2 id="运行Zipkin"><a href="#运行Zipkin" class="headerlink" title="运行Zipkin"></a>运行Zipkin</h2><p>根据<a href="https://github.com/openzipkin/zipkin">仓库</a>Readme中的提示下载运行Jar即可。</p><p>默认在本地的9411端口启动，用浏览器可以进入。</p><p>Zipkin中有一些关键概念：</p><ul><li><p>Trace：Zipkin使用Trace结构表示对一次请求的跟踪，一次请求可能由后台的若干服务负责处理，每个服务的处理是一个Span，Span之间有依赖关系，Trace就是树结构的Span集合。</p></li><li><p>Span：每个服务的处理跟踪是一个Span，可以理解为一个基本的工作单元，包含了一些描述信息：id，parentId，name，timestamp，duration，annotations等。</p></li></ul><h2 id="整合Sleuth"><a href="#整合Sleuth" class="headerlink" title="整合Sleuth"></a>整合Sleuth</h2><p>除了注册中心之类的东西，都需要添加Sleuth进行上报，添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span> <span class="hljs-comment">#默认启动的Zipkin服务器地址</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1</span> <br>      <span class="hljs-comment"># 配置采样率</span><br>      <span class="hljs-comment"># 默认的采样比例为: 0.1，即 10%，所设置的值介于 0 到 1 之间</span><br>      <span class="hljs-attr">rate:</span> <span class="hljs-number">10</span> <br>      <span class="hljs-comment"># 为了使用速率限制采样器，每秒间隔接受的 trace 量</span><br>      <span class="hljs-comment"># 最小数字为 0，最大值为 INT_MAX</span><br></code></pre></td></tr></table></figure><h1 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h1><p>Spring Boot Admin 用于监控基于 Spring Boot 的应用，它是在 Spring Boot Actuator 的基础上提供简洁的可视化 WEB UI。Spring Boot Admin 提供了很多功能，如显示 name、id 和 version，显示在线状态，Loggers 的日志级别管理，Threads 线程管理，Environment 管理等。</p><p>在 Spring Boot 项目中，Spring Boot Admin 作为 Server 端，其他的要被监控的应用作为 Client 端。</p><h2 id="监控Admin-Server端"><a href="#监控Admin-Server端" class="headerlink" title="监控Admin&#x2F;Server端"></a>监控Admin&#x2F;Server端</h2><p>添加依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- admin server --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- admin server ui --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-server-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--添加admin安全登录界面，可选--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 通常需要向注册中心注册, 引入eureka客户端--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类需要添加注解<code>@EnableAdminServer</code>。</p><p>并配置注册Eureka和安全相关：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 向注册中心注册</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">admin-server</span><br><span class="hljs-comment"># 监控网页的端口 </span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9041</span><br><span class="hljs-comment"># Eureka</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span> <br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">...</span><br><span class="hljs-comment"># admin安全配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">security:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">admin</span><br>      <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">metadata-map:</span><br>      <span class="hljs-attr">user:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">$&#123;spring.security.user.name&#125;</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-string">$&#123;spring.security.user.password&#125;</span><br><span class="hljs-comment"># 我觉得安全配置多此一举，后面通过Gateway限制就好了</span><br></code></pre></td></tr></table></figure><h2 id="被监控Client端"><a href="#被监控Client端" class="headerlink" title="被监控Client端"></a>被监控Client端</h2><p>需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过Actuator暴露服务的健康数据等（实际上是一堆&#x2F;actuator开头的接口）。</p><p>默认只暴露少量健康信息，想要更多信息（详细到Beans），需要配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-comment">#表示全部</span><br></code></pre></td></tr></table></figure><blockquote><p>其实我觉得没必要整这个东西，只需要加个Actuator依赖配置下暴露的内容，用IDEA自带的调试看看就够了。</p></blockquote><h1 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h1><p>SpringCloud Gateway是Spring官方用来取代Netflix Zuul的新网关组件，通过它和注册中心我们可以负载均衡地访问各个服务，无需知道服务具体的端口。如果你了解过NGINX，那么可以看做它的阉割版。</p><p>举个例子，通过访问80端口网关的<code>/provider-a/abc/method?value=...</code>通过配置可以转发到位于6666端口的服务上调用<code>/abc/method?value=...</code>，而前端无需知道服务在6666端口上。</p><p>Gateway的工作流程类似Tomcat等Web容器，客户端发出请求，然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler，其再通过一系列指定的过滤器(PRE过滤器)来将请求发送到我们实际的服务的业务逻辑，然后返回，会再经过过滤器链(POST过滤器)回到用户手里。</p><blockquote><p>Gateway是运行在Netty上基于Webflux构建的，但使用起来没有什么差别。</p></blockquote><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>Route 路由</td><td>包含ID、目标URI、断言和过滤，相当于一条反向代理设置</td></tr><tr><td>Predicate 断言</td><td>通过请求中各种信息决定是否可以走这条路由</td></tr><tr><td>Filter 过滤</td><td>对请求和响应进行处理</td></tr></tbody></table><h2 id="建立网关"><a href="#建立网关" class="headerlink" title="建立网关"></a>建立网关</h2><p>SpringCloud Gateway就像Eureka，引入依赖启动就是一个网关。</p><p>通常需要引入Gateway本身和注册中心客户端，注册中心客户端用于拿到其他服务进行动态路由。你可以通过Spring Initializr添加Gateway和Eureka Discovery Client或者手动添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用Eureka客户端，当然需要在启动类前添加<code>@EnableDiscoveryClient</code>。</p><p>添加了Gateway依赖就会自动配置启用，但我们需要配置其他一些东西：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 显然，我们需要连接上Eureka服务端</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka</span><br><span class="hljs-comment"># 我们还需要给他一个名字</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br><span class="hljs-comment"># 网关通常在80端口上</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>我们可以使用动态路由或静态路由，动态路由通过注册中心拿到具体的服务地址并有负载均衡，而静态路由只是简单地帮你转发到一个固定的地址上，通常项目中都是使用动态路由。</p><h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>这是一个配置静态路由的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">a-route</span>            <span class="hljs-comment">#规则id或者名称，不重复即可</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://dest.com</span>   <span class="hljs-comment">#目标URI</span><br>          <span class="hljs-attr">predicates:</span>            <span class="hljs-comment">#断言</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/out/**</span>       <span class="hljs-comment">#Path断言</span><br><span class="hljs-comment">#当访问gateway的/out/**时，相当于访问http://dest.com/out/**</span><br></code></pre></td></tr></table></figure><p>有时候我们想实现通过访问gateway的&#x2F;a&#x2F;doApi来调用目标的&#x2F;doApi，而没有前面的&#x2F;a&#x2F;，这需要过滤器StripPrefix：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">filters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=2</span> <span class="hljs-comment">#数字表示去掉几级，填2时/a/b/doApi会在目标上变成/doApi</span><br></code></pre></td></tr></table></figure><blockquote><p>断言和过滤器非常多，具体可以看<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#">文档</a>查阅。</p></blockquote><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>动态路由只需要在自身已经注册到注册中心的情况下，开启即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 默认没启用</span><br>          <span class="hljs-attr">lower-case-service-id:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 默认是全大写</span><br></code></pre></td></tr></table></figure><p>然后就可以通过<code>.../服务名称/method?value....</code>的方式访问各个服务，并有负载均衡。</p><p>但如果你想像静态路由那样给个自定义路径名称，那就需要：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">locator:</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 还是需要启用的</span><br>          <span class="hljs-attr">lower-case-service-id:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">a-route</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://service-name</span> <span class="hljs-comment"># 微服务的名称，注意lb://</span><br>          <span class="hljs-attr">predicates:</span>           <br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/service/**</span>      <br></code></pre></td></tr></table></figure><p>此时访问gateway的<code>/service/doApi</code>就相当于访问service-name服务的<code>/service/doApi</code>。</p><p>注意URI的协议为lb(LoadBalance)，表示启用Gateway的负载均衡功能，网关将类似使用Ribbon那样自动将服务名称转换为地址。</p><blockquote><p>使用动态路由时，你实现GloabalFileter时exchange.getRequest().getPath()将会得到带有服务名称前缀的请求路径！如：&#x2F;service-xxx&#x2F;api&#x2F;method</p></blockquote><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>现在不用在Boot项目的每个控制器前加@CrossOrigin这种东西了，只需要对网关进行配置。</p><p>可以在配置文件中添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">globalcors:</span><br>        <span class="hljs-attr">corsConfigurations:</span><br>          <span class="hljs-string">&#x27;[/**]&#x27;</span><span class="hljs-string">:</span>    <span class="hljs-comment"># 表示放行全部</span><br>            <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-string">&quot;*&quot;</span>    <span class="hljs-comment"># 表示允许所有源</span><br>            <span class="hljs-attr">allowedMethods:</span> <span class="hljs-string">&quot;*&quot;</span>    <span class="hljs-comment"># 表示允许所有请求方法</span><br>            <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span>    <span class="hljs-comment"># 表示不关心请求头</span><br></code></pre></td></tr></table></figure><p>上面配置应该和下面这种配置类方式一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CorsWebFilter <span class="hljs-title function_">corsFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>        config.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br>        config.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br>        config.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br>        <span class="hljs-type">UrlBasedCorsConfigurationSource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlBasedCorsConfigurationSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PathPatternParser</span>());<br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsWebFilter</span>(source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是简单的全局跨域，作用于网关下所有微服务，可能会影响到应用的其它部分。如果需要更细粒度的控制，可以使用路由规则级别的配置方法。</p><p>添加一个跨域过滤器：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">default-filters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cors</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-attr">allowedOrigins:</span> <span class="hljs-string">&quot;*&quot;</span><br>          <span class="hljs-attr">allowedMethods:</span> <span class="hljs-string">&quot;*&quot;</span><br>          <span class="hljs-attr">allowedHeaders:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p>像这样作用于某个路由规则：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">my_route</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">http://example.com</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/my/path/**</span><br>        <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cors</span><br></code></pre></td></tr></table></figure><p>也可以使用自定义但没必要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomCorsFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CorsWebFilter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomCorsFilter</span><span class="hljs-params">(CorsConfigurationSource configSource)</span> &#123;<br>        <span class="hljs-built_in">super</span>(configSource);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, org.springframework.web.filter.reactive.HiddenHttpMethodFilter.HiddenHttpMethodRequestWrapper request, org.springframework.web.filter.reactive.HiddenHttpMethodFilter.HiddenHttpMethodResponseWrapper response)</span> &#123;<br>        <span class="hljs-keyword">if</span> (CorsUtils.isCorsRequest(exchange.getRequest())) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.filter(exchange, request, response);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Mono.empty();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="断言工厂简单了解"><a href="#断言工厂简单了解" class="headerlink" title="断言工厂简单了解"></a>断言工厂简单了解</h2><p>这里说的断言其实是Java的Lambda中的一种“预设”，你应该早就见过了诸如Consumer、Supplier之类的，而Predicate就是接受参数返回boolean的一个断言&#x2F;判断函数，就像<code>boolean isValueOk(Object inValue)</code>。</p><p>通俗的说，断言就是一些布尔表达式，满足条件的返回 true，不满足的返回 false。Spring Cloud Gateway将路由作为Spring WebFlux HandlerMapping基础架构的一部分进行匹配。所有这些断言都与HTTP请求的不同属性匹配。</p><p>这些断言的作用如下图所示：</p><p><img src="/images/2023/springcloud_predicate.jpg"></p><p>一些使用的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言匹配</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/info/**</span> <span class="hljs-comment">#和服务中的路径匹配,是正则匹配的模式</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">After=2020-01-20T17:42:47.789-07:00[Asia/Shanghai]</span> <span class="hljs-comment">#此断言匹配发生在指定日期时间之后的请求，ZonedDateTime dateTime=ZonedDateTime.now()获得</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Before=2020-06-18T21:26:26.711+08:00[Asia/Shanghai]</span> <span class="hljs-comment">#此断言匹配发生在指定日期时间之前的请求</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Between=2020-06-18T21:26:26.711+08:00[Asia/Shanghai],2020-06-18T21:32:26.711+08:00[Asia/Shanghai]</span> <span class="hljs-comment">#此断言匹配发生在指定日期时间之间的请求</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Host=**.bai*.com:*</span> <span class="hljs-comment">#主机路由断言工厂接受一个参数:主机名模式列表。该模式是一个 ant 样式的模式。作为分隔符。此断言匹配与模式匹配的主机头</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Method=GET,POST</span> <span class="hljs-comment">#方法路由断言工厂接受一个方法参数，该参数是一个或多个参数:要匹配的 HTTP 方法</span><br></code></pre></td></tr></table></figure><p>断言也可以自定义，但是自带的已经足够，通常没人去自定义。</p><h2 id="过滤器工厂简单了解"><a href="#过滤器工厂简单了解" class="headerlink" title="过滤器工厂简单了解"></a>过滤器工厂简单了解</h2><p>过滤器分为针对某一条路由的GatewayFilter和作用于所有路由的GlobalFilter，并且这些过滤器的作用与之前用过的Web容器或者说Servlet中的基本一致，如果你还记得如何用拦截器实现登录验证功能那你应该不会有什么疑问。</p><p>与断言不同的是，过滤器通常是我们自己自定义实现的，用来实现登录之类的功能。</p><h3 id="一个全局拦截是否有token的例子"><a href="#一个全局拦截是否有token的例子" class="headerlink" title="一个全局拦截是否有token的例子"></a>一个全局拦截是否有token的例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//需要注册为Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalFilterConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">//获取请求的信息，和HttpServletRequest很类似</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> exchange.getRequest() <span class="hljs-comment">//exchange包含请求和响应</span><br>                                .getQueryParams() <span class="hljs-comment">//url参数</span><br>                                .getFirst(<span class="hljs-string">&quot;token&quot;</span>); <span class="hljs-comment">//获取</span><br>        <span class="hljs-keyword">if</span> (token == <span class="hljs-literal">null</span>) &#123;<br>            log.error(<span class="hljs-string">&quot;token 为空，说明没有认证&quot;</span>);<br>            <span class="hljs-comment">//设置Response的状态码</span><br>            exchange.getResponse()<br>                    .setStatusCode(HttpStatus.NOT_ACCEPTABLE);<br>            <span class="hljs-comment">//过滤器链不继续往下传，开始返回</span><br>            <span class="hljs-keyword">return</span> exchange.getResponse().setComplete();<br>        &#125;<br>        <span class="hljs-comment">//放行，传入下一个过滤器中</span><br>        <span class="hljs-keyword">return</span> chain.filter(exchange);<br>    &#125;<br>    <span class="hljs-comment">// 在过滤器链中的优先级，越小优先级越高，越先执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一个限流过滤器例子"><a href="#一个限流过滤器例子" class="headerlink" title="一个限流过滤器例子"></a>一个限流过滤器例子</h3><p>限制一段时间内，用户访问资源的次数，减轻服务器压力，有对用户IP进行访问次数限制和一段时间内对接口请求次数的限制。</p><p>以通过令牌桶算法与Redis为例实现。</p><p>首先我们需要在使用Gateway的基础上引入Redis的依赖<code>&gt;spring-boot-starter-data-redis-reactive</code>，然后在配置文件中连接Redis并配置过滤器：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">routes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user-service</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://consumer-user-service</span><br>          <span class="hljs-attr">predicates:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/info/**</span><br>      <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RequestRateLimiter</span> <span class="hljs-comment"># 过滤器的名称，Redis提供的，就叫这个名</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-attr">key-resolver:</span> <span class="hljs-string">&#x27;#&#123;@hostAddrKeyResolver&#125;&#x27;</span> <span class="hljs-comment"># 限流键解析器Bean的名称，见下文</span><br>            <span class="hljs-attr">redis-rate-limiter.replenishRate:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 每秒令牌补充数量</span><br>            <span class="hljs-attr">redis-rate-limiter.burstCapacity:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 令牌桶的大小</span><br>  <span class="hljs-attr">redis:</span> <span class="hljs-comment">#redis 的配置</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.226</span><span class="hljs-number">.128</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>创建配置类，包含上文的限流解析器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestRateLimiterConfig</span> &#123;<br>    <span class="hljs-comment">//IP 限流，把用户的 IP 作为限流的 Key</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Primary</span> <span class="hljs-comment">//作为Bean的主候选，根据情况而加，通常不加</span><br>    <span class="hljs-keyword">public</span> KeyResolver <span class="hljs-title function_">hostAddrKeyResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (exchange) -&gt; Mono.just(exchange.getRequest().getRemoteAddress().getHostName());<br>    &#125;<br>    <br>    <span class="hljs-comment">//用户 id 限流，把用户 ID 作为限流的 key</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> KeyResolver <span class="hljs-title function_">userKeyResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(<span class="hljs-string">&quot;userId&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-comment">//请求接口限流，把请求的路径作为限流 key</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> KeyResolver <span class="hljs-title function_">apiKeyResolver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getPath().value());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SpringCloud工程项目布局"><a href="#SpringCloud工程项目布局" class="headerlink" title="SpringCloud工程项目布局"></a>SpringCloud工程项目布局</h1><p>SpringCloud项目通常是一个Maven父模块带着几个SpringBoot子模块，而父模块一般继承SpringBoot爷爷模块。</p><p>以IDEA为例，个人习惯是用Spring Initializr先创建一个SpringBoot项目，并且顺便勾选Cloud的依赖（比如Eureka），然后用Spring Initializr创建子模块，修改pom中的父模块指向。</p><p>将得到父模块的pom中将有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringBoot爷爷项目 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 关键，父模块并无代码而是一个管理者 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 拥有的子模块，子模块里也需要设置父模块 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>EurekaServer<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 一些参数，也将传递给子模块，通常是JDK版本和库版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>2022.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.eureka.version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.eureka.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 一些传递给子模块的依赖，通常是公共、大家都需要的模块 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 依赖管理，不会真的添加依赖，只是管理子模块依赖的版本 --&gt;</span><br><span class="hljs-comment">&lt;!-- 这里使用$&#123;&#125;读取了上面的properties，子模块中也因此无需指定版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.eureka.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用Spring Initializr创建的pom还会有build块，需要删掉，因为父模块不需要编译！</p></blockquote><p>子模块的pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>父模块组ID<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>父模块工件名<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>父模块版本<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 打包方式就可以为jar或war了 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 当前模块名，要与父模块modules中的一致 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>EurekaServer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 当前模块的依赖，如果父模块中的dependencyManagement已经写了版本，像这里就无需再写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 要调用其他自己写的模块，也是在这里添加 --&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>因为使用Spring Initializr不能指定父模块，所以你需要自己注意所有子模块和父模块都应该在一个组下。</p></blockquote><p>而子模块之间可以抽离出一些公用的东西，比如将所有实体类、DAO层、Redis操作等都抽离出来放到类似service-common的子模块中，这在使用MybatisPlus并配合MybatisX插件生成DAO层和CRUD服务层时非常方便。</p><p>此时只要其他模块在dependencies中添加你的common模块，并在使用common模块的模块都配置好数据库和Redis连接地址即可。（最好把common模块里的配置文件删掉）</p><blockquote><p>据说还可以通过配置中心或者配置文件包含之类的方式统一设置，笔者对此并不了解且可能会引发问题，后面可能会更新。另外，上述做法还能让不同模块用不同的数据源。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ使用 SpringBoot整合篇</title>
    <link href="/2022/RabbitMQ%E4%BD%BF%E7%94%A8SpringBoot%E7%AF%87/"/>
    <url>/2022/RabbitMQ%E4%BD%BF%E7%94%A8SpringBoot%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>无SpringBoot的基础使用见<a href="/2022/rabbitmq%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/">另一篇文章</a>。</p><h1 id="引入依赖与配置"><a href="#引入依赖与配置" class="headerlink" title="引入依赖与配置"></a>引入依赖与配置</h1><p>Maven添加Starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot的配置文件中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.137</span><span class="hljs-number">.16</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">admin</span><br><span class="hljs-comment"># 不会有笨蛋直接COPY吧</span><br></code></pre></td></tr></table></figure><p>不需要在生产者或消费者声明队列和交换机，被配置类替代。</p><p>我将以我看的教程的顺序，即以例子来逐步记录。</p><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="延迟队列-Pro"><a href="#延迟队列-Pro" class="headerlink" title="延迟队列 Pro"></a>延迟队列 Pro</h2><p>只需要在配置类中配置好复杂的死信队列结构，就可以轻松使用。</p><p><img src="/images/2022/rabbitmq_delayqueue_pro.png"></p><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMqConfig</span> &#123;<br>    <span class="hljs-comment">//结构与上图中的基本相同</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;X&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Y&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_QUEUE_1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QA&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_QUEUE_2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QB&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QD&quot;</span>;<br>    <span class="hljs-comment">//声明普通交换机</span><br>    <span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(NORMAL_EXCHANGE);<br>    &#125;<br>    <span class="hljs-comment">//声明死信交换机</span><br>    <span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(DEAD_EXCHANGE);<br>    &#125;<br>    <span class="hljs-comment">//声明两个普通队列</span><br>    <span class="hljs-meta">@Bean(&quot;queueA&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .nonDurable(NORMAL_QUEUE_1)<br>                .ttl(<span class="hljs-number">10000</span>)<br>                .deadLetterExchange(DEAD_EXCHANGE) <span class="hljs-comment">//死信交换机与RoutingKey</span><br>                .deadLetterRoutingKey(<span class="hljs-string">&quot;YD&quot;</span>)<br>                .build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;queueB&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .nonDurable(NORMAL_QUEUE_2)<br>                .ttl(<span class="hljs-number">40000</span>)<br>                .deadLetterExchange(DEAD_EXCHANGE)<br>                .deadLetterRoutingKey(<span class="hljs-string">&quot;YD&quot;</span>)<br>                .build();<br>    &#125;<br>    <span class="hljs-comment">//声明死信队列</span><br>    <span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueDead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(DEAD_QUEUE).build();<br>    &#125;<br>    <span class="hljs-comment">//队列绑定</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueABindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue qA, <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange ex)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(qA).to(ex).with(<span class="hljs-string">&quot;XA&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue qB, <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange ex)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(qB).to(ex).with(<span class="hljs-string">&quot;XB&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueDBindingX</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue qD, <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange ex)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(qD).to(ex).with(<span class="hljs-string">&quot;YD&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>留意@Bean(“”)与@Qualifier(“”)的使用。</p></blockquote><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>跟随教程使用Controller实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-comment">//发送消息的关键</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">//测试发送的接口</span><br>    <span class="hljs-meta">@GetMapping(&quot;/send/&#123;msg&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;msg&quot;)</span> String message)</span> &#123;<br>        LoggerFactory.getLogger(TestController.class).info(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), message);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XA&quot;</span>, <span class="hljs-string">&quot;Hi&quot;</span>);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;X&quot;</span>, <span class="hljs-string">&quot;XB&quot;</span>, <span class="hljs-string">&quot;Hi&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者（死信）"><a href="#消费者（死信）" class="headerlink" title="消费者（死信）"></a>消费者（死信）</h3><p>消费者使用使用注解实现监听某个队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLetterConsumer</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span> <span class="hljs-comment">//监听QD</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.info(<span class="hljs-string">&quot;Consumer: &#123;&#125;,&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是的没错，使用<code>@RabbitListener</code>来声明一个方法作为Consumer，这里的参数列表自由发挥，一般来说需要一个Message。</p><h2 id="延迟队列-Pro-Plus"><a href="#延迟队列-Pro-Plus" class="headerlink" title="延迟队列 Pro Plus"></a>延迟队列 Pro Plus</h2><p>上面的延迟队列，你要新的延迟时间就要创建新的队列，太笨比。</p><p>应该由生产者指定过期时间，发送到一个没有设置过期时间的队列上（仍然没有消费者）。</p><p><img src="/images/2022/rabbitmq_deadqueue_proplus.png"></p><h3 id="配置类-1"><a href="#配置类-1" class="headerlink" title="配置类"></a>配置类</h3><p>只是减少了TTL设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMqConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_ROUTINGKEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay_key&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_ROUTINGKEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_key&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEAD_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dead_queue&quot;</span>;<br>    <span class="hljs-meta">@Bean(&quot;nExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">nExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(DELAY_EXCHANGE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;dExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">dExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(DEAD_EXCHANGE);<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;delay_queue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .nonDurable(DELAY_QUEUE)<br>                .deadLetterExchange(DEAD_EXCHANGE)<br>                .deadLetterRoutingKey(DEAD_ROUTINGKEY)<br>                .build();<br>    &#125;<br>    <span class="hljs-meta">@Bean(&quot;dead_queue&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">deadQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(DEAD_QUEUE).build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingDelay</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delay_queue&quot;)</span> Queue que, <span class="hljs-meta">@Qualifier(&quot;nExchange&quot;)</span> DirectExchange ex)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(que).to(ex).with(DELAY_ROUTINGKEY);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingDead</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;dead_queue&quot;)</span> Queue que, <span class="hljs-meta">@Qualifier(&quot;dExchange&quot;)</span> DirectExchange ex)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(que).to(ex).with(DEAD_ROUTINGKEY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-comment">//测试发送的接口</span><br>    <span class="hljs-meta">@GetMapping(&quot;/send/&#123;msg&#125;/&#123;ttl&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg, <span class="hljs-meta">@PathVariable</span> String ttl)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Send in TTL &#123;&#125; : &#123;&#125;&quot;</span>, ttl, msg);<br>        rabbitTemplate.convertAndSend(<br>                MyMqConfig.DELAY_EXCHANGE,<br>                MyMqConfig.DELAY_ROUTINGKEY,<br>                msg.getBytes(StandardCharsets.UTF_8),<br>                message -&gt; &#123;<br>                    <span class="hljs-comment">//设置TTL</span><br>                    message.getMessageProperties().setExpiration(ttl);<span class="hljs-comment">//ms</span><br>                    <span class="hljs-keyword">return</span> message;<br>                &#125;<br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键在于MessagePostProcessor，其签名实际如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MessagePostProcessor</span> &#123;<br>    Message <span class="hljs-title function_">postProcessMessage</span><span class="hljs-params">(Message var1)</span> <span class="hljs-keyword">throws</span> AmqpException;<br><br>    <span class="hljs-keyword">default</span> Message <span class="hljs-title function_">postProcessMessage</span><span class="hljs-params">(Message message, Correlation correlation)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.postProcessMessage(message);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Message <span class="hljs-title function_">postProcessMessage</span><span class="hljs-params">(Message message, Correlation correlation, String exchange, String routingKey)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.postProcessMessage(message, correlation);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的是第一个，只有一个Message的“重载”，对消息进行操作原样返回即可。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果前面发的一条消息延迟很大，而后面的延迟很小，会堵在前面的消息等待TTL（队列先进先出特性）。</p><p>该问题不引入插件目前无解。</p><h2 id="延迟队列-Pro-Plus-Max（基于插件）"><a href="#延迟队列-Pro-Plus-Max（基于插件）" class="headerlink" title="延迟队列 Pro Plus Max（基于插件）"></a>延迟队列 Pro Plus Max（基于插件）</h2><p>要想解决上面的问题，需要插件来让RabbitMQ支持该功能。</p><h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>到RabbitMQ网站上下载，<a href="https://www.rabbitmq.com/community-plugins.html">社区插件</a>。</p><p>也可以到Github，<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">链接</a>。</p><p>藏得有点深。</p><p>找到插件目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmq-plugins directories -s<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通常输出</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Plugin archives directory: /usr/lib/rabbitmq/plugins:/usr/lib/rabbitmq/lib/rabbitmq_server-3.11.2/plugins</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Plugin expansion directory: /var/lib/rabbitmq/mnesia/rabbit@debian-plugins-expand</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Enabled plugins file: /etc/rabbitmq/enabled_plugins</span><br></code></pre></td></tr></table></figure><p>把下载的插件安装包丢到Plugin Archives目录。</p><p>启用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure><p>最后重启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart rabbitmq-server.service <br></code></pre></td></tr></table></figure><p>安装成功后，可在管理界面创建交换机时看到新的类型，x-delayed-message。这也意味着，延迟队列实现从利用死信队列变为使用交换机。新的结构如下：</p><p><img src="/images/2022/rabbitmq_delayqueue_proplusmax.png"></p><h3 id="配置类-2"><a href="#配置类-2" class="headerlink" title="配置类"></a>配置类</h3><p>新的交换机类型需要额外的配置，没有那个类了，需要自定义交换机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMqConfig</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay_exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay_queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_RK</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay_rk&quot;</span>;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title function_">delayExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//交换机参数填上类型，其实就是延迟+什么基础类型的交换机，可以是直接、扇出等</span><br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        args.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<span class="hljs-comment">//一般用Direct</span><br>        <span class="hljs-comment">//CustomExchange(String name, String type, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments)</span><br>        <span class="hljs-comment">//在第二个参数——交换机类型填上我们的新交换机类型</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomExchange</span>(DELAY_EXCHANGE, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.nonDurable(DELAY_QUEUE).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">delayExchangeBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayExchange&quot;)</span> CustomExchange ex, <span class="hljs-meta">@Qualifier(&quot;delayQueue&quot;)</span> Queue que)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(que).to(ex).with(DELAY_RK).noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>留意@Bean与@Qualifier(“”)的使用。</p></blockquote><h3 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h3><p>只变了设置延迟的一行。</p><p>生产者发送消息设置Expiration变为设置Delay。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br>    <span class="hljs-comment">//测试发送的接口</span><br>    <span class="hljs-meta">@GetMapping(&quot;/send/&#123;msg&#125;/&#123;ttl&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg, <span class="hljs-meta">@PathVariable</span> String ttl)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;Send in TTL &#123;&#125; : &#123;&#125;&quot;</span>, ttl, msg);<br>        rabbitTemplate.convertAndSend(<br>                MyMqConfig.DELAY_EXCHANGE,<br>                MyMqConfig.DELAY_RK,<br>                msg.getBytes(StandardCharsets.UTF_8),<br>                message -&gt; &#123;<br>                    <span class="hljs-comment">//从setExpiration变成了setDelay</span><br>                    message.getMessageProperties().setDelay(Integer.parseInt(ttl));<span class="hljs-comment">//ms</span><br>                    <span class="hljs-keyword">return</span> message;<br>                &#125;<br>        );<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="延迟队列-总结"><a href="#延迟队列-总结" class="headerlink" title="延迟队列 总结"></a>延迟队列 总结</h2><p>利用RabbitMQ特性实现需要延迟的场景，可以简化并且消息不会丢失（开了持久化）。</p><p>在开发中要使用延迟队列，首选是使用基于插件的方法，但如果每个任务的延迟是固定的那么用死信队列也行。</p><h1 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h1><h2 id="交换机确认"><a href="#交换机确认" class="headerlink" title="交换机确认"></a>交换机确认</h2><p>和基础篇中的情况基本一致，把消息缓存起来以防交换机寄了没机会重传。</p><h3 id="配置与配置类"><a href="#配置与配置类" class="headerlink" title="配置与配置类"></a>配置与配置类</h3><p>需要在配置文件中启用发布确认：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span><br><span class="hljs-comment"># none:</span><br><span class="hljs-comment"># 关闭发布确认，默认值</span><br><span class="hljs-comment"># simple:</span><br><span class="hljs-comment"># &quot;Use waitForConfirms() or waitForConfirmsOrDie() within scoped operations.&quot;，用在同步模式，这两个方法返回false会关闭channel无法再发送消息</span><br><span class="hljs-comment"># correlated:</span><br><span class="hljs-comment"># &quot;Use with CorrelationData to correlate confirmations with sent messsages.&quot;，用在异步回调模式</span><br></code></pre></td></tr></table></figure><p>结构是，简单的一生产者一消费者与一直接交换机和消费者的队列，串联起来，硬要看配置类的话就：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMqConfig</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;E&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RK&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Q&quot;</span>;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">theExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EXCHANGE_NAME).autoDelete().build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">theQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_NAME).autoDelete().build();<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">theBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;theExchange&quot;)</span> DirectExchange exchange, <span class="hljs-meta">@Qualifier(&quot;theQueue&quot;)</span> Queue queue)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(ROUTING_KEY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>留意ExchangeBuilder。</p></blockquote><h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置确认回调方法，等同于异步回调</span><br>rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;<br>    <span class="hljs-comment">//correlationData可能为null，这玩意是在生产者自己填写的，没填写就没有</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (<span class="hljs-literal">null</span> == correlationData) ? <span class="hljs-string">&quot;&quot;</span> : correlationData.getId();<br>    <span class="hljs-keyword">if</span> (ack) log.info(<span class="hljs-string">&quot;Success &#123;&#125;&quot;</span>, id);<br>    <span class="hljs-keyword">else</span> log.error(<span class="hljs-string">&quot;Fail &#123;&#125;, Reason: &#123;&#125;&quot;</span>, id, cause);<br>&#125;);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Callback原型：</span><br><span class="hljs-comment"> * public interface ConfirmCallback &#123;</span><br><span class="hljs-comment"> * void confirm (@Nullable CorrelationData correlationData,boolean ack,@Nullable String cause);</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> *  correlationData     消息的ID及相关信息</span><br><span class="hljs-comment"> *  ack                 交换机是否收到消息</span><br><span class="hljs-comment"> *  cause               失败的原因，没失败为null</span><br><span class="hljs-comment"> */</span><br><br>rabbitTemplate.convertAndSend(<br>        MyMqConfig.EXCHANGE_NAME,<br>        MyMqConfig.ROUTING_KEY,<br>        msg.getBytes(StandardCharsets.UTF_8)<br><span class="hljs-comment">//      ,new CorrelationData(....)</span><br>);<br></code></pre></td></tr></table></figure><blockquote><p>记得填写CorrelationData。</p></blockquote><p>如何重发消息请看基础篇，需要注意的是这里ID就不用什么deliverTag了，自己生成个填CorrelationData里吧。</p><p>可以尝试掐网线、写错交换机名称来模仿到交换机的丢包。</p><blockquote><p>和基础篇中的一样，不可感知交换机后的如不可路由等失败的丢失。解决见下方。</p></blockquote><h2 id="回退消息（队列确认）"><a href="#回退消息（队列确认）" class="headerlink" title="回退消息（队列确认）"></a>回退消息（队列确认）</h2><p>将交换机发送到队列失败的消息回退给生产者，好让生产者处理。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>需要配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h3><p>其他部分与上一个生产者的相同，设置回调如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置回退回调方法</span><br>rabbitTemplate.setReturnsCallback(returned -&gt; &#123;<br>    log.error(<span class="hljs-string">&quot;Returned: &#123;&#125;, Reason: &#123;&#125;, Exchange: &#123;&#125;, RoutingKey: &#123;&#125;&quot;</span>,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(returned.getMessage().getBody(), StandardCharsets.UTF_8),<br>            returned.getReplyText(),<br>            returned.getExchange(),<br>            returned.getRoutingKey());<br>&#125;);<br><span class="hljs-comment">//returned中，储存的是被退回的消息的，交换机、路由键、消息体(自己send的对象)、原因(replyText)</span><br></code></pre></td></tr></table></figure><p>当遇到上述所谓无法路由的情况时，该回调会打印：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Returned:</span> <span class="hljs-string">aaa,</span> <span class="hljs-attr">Reason:</span> <span class="hljs-string">NO_ROUTE,</span> <span class="hljs-attr">Exchange:</span> <span class="hljs-string">E,</span> <span class="hljs-attr">RoutingKey:</span> <span class="hljs-string">RK114514ERROR</span><br></code></pre></td></tr></table></figure><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><h2 id="消息序列化"><a href="#消息序列化" class="headerlink" title="消息序列化"></a>消息序列化</h2><p>RabbitMQ的MessageConvert接口处理消息的序列化，其实现有 SimpleMessageConverter（默认）、Jackson2JsonMessageConverter等。当调用了 convertAndSend 时会使用 MessageConvert 进行消息对象的序列化。</p><p>SimpleMessageConverter 对于要发送的消息体 body：</p><ul><li>为 byte[] 时不进行处理</li><li>是 String 则转成字节数组</li><li>是 Java 对象，则用JDK自带序列化将消息转成字节数组，性能较差</li></ul><p>Jackson2JsonMessageConverter顾名思义转成JSON。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Java</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ使用 基础篇</title>
    <link href="/2022/RabbitMQ%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <url>/2022/RabbitMQ%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>概念见<a href="/2022/rabbitmq%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">另一篇文章</a>。</p><h1 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h1><p>引入RabbitMQ的连接“客户端”，Maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.16.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SpringBoot的话直接：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="简单模式（单收单发）"><a href="#简单模式（单收单发）" class="headerlink" title="简单模式（单收单发）"></a>简单模式（单收单发）</h1><p><img src="https://www.rabbitmq.com/img/tutorials/python-one.png"></p><p>一个生产者在RabbitMQ上发送消息到指定队列，一个消费者在RabbitMQ上的指定队列接收消息。</p><p>生产者和消费者都连接到RabbitMQ，代码是相同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建连接工厂</span><br><span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br><span class="hljs-comment">//设置RabbitMQ服务器的地址</span><br>factory.setHost(<span class="hljs-string">&quot;localhost&quot;</span>);<br><span class="hljs-comment">//服务器的端口</span><br>factory.setPort(<span class="hljs-number">5672</span>);<br><span class="hljs-comment">//连接的用户名与密码</span><br>factory.setUsername(<span class="hljs-string">&quot;admin&quot;</span>);<br>factory.setPassword(<span class="hljs-string">&quot;admin&quot;</span>);<br><span class="hljs-comment">//获取连接</span><br>connection = factory.newConnection();<br></code></pre></td></tr></table></figure><p>RabbitMQ的默认端口是5672！</p><p>获得连接之后，可以“声明”信道了，代码是相同的。</p><blockquote><p>需要注意的是，任意一方声明信道都可以，重复申请信道不会出现问题，但是没有创建信道一定翻车。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过连接创建信道</span><br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><span class="hljs-comment">//“声明”队列</span><br>channel.queueDeclare(<span class="hljs-string">&quot;queue-a&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>queueDeclare()创建队列的参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>queue</td><td>队列名称，收发两端的要一致</td></tr><tr><td>durable</td><td>是否持久化，就是是否把消息存硬盘上而不是只是内存里</td></tr><tr><td>exclusive</td><td>是否独占，是否可以有超过一个消费者</td></tr><tr><td>autoDelete</td><td>是否在队列无人使用后自动删除</td></tr><tr><td>arguments</td><td>其他参数</td></tr></tbody></table><blockquote><p>注意，如队列是否持久化、是否独占等参数需要更改，需要删除原先的队列（可以在管理页面操作）。</p></blockquote><h2 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h2><p>发送消息可以通过信道的方法basicPublish进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;queue-a&quot;</span>, <span class="hljs-literal">null</span>, str.getBytes(StandardCharsets.UTF_8));<br><span class="hljs-comment">//basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li><p>第一个参数为交换机名称，当前模式下不需要，则留空。</p></li><li><p>路由Key名称，当前模式下写队列的名称。</p><p>（按我个人理解，其实路由Key就是指走向哪个队列，在路由模式下，同一个交换机的不同队列就靠该参数区分）</p></li><li><p>其他参数</p></li><li><p>消息体</p></li></ol><blockquote><p>“其他参数”可以设置为MessageProperties.PERSISTENT_TEXT_PLAIN等实现消息持久化。</p></blockquote><h2 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h2><p>接受消息使用信道的方法basicConsume进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicConsume(<span class="hljs-string">&quot;queue-a&quot;</span>, <span class="hljs-literal">true</span>,<br>  (consumerTag, message) -&gt; &#123;<span class="hljs-comment">/*消息处理回调方法*/</span>&#125;,<br>  consumerTag -&gt; &#123;<span class="hljs-comment">/*“消息被取消”回调方法*/</span>&#125;);<br><span class="hljs-comment">//参数1：队列名称</span><br><span class="hljs-comment">//参数2：是否自动应答</span><br><span class="hljs-comment">//  自动应答指消息未处理完，但直接响应处理完成，继而继续接受下一个消息。</span><br><span class="hljs-comment">//  当消息处理耗时时，自动应答将会导致OOM之类的。</span><br></code></pre></td></tr></table></figure><p>如果需要手动应答，则把basicConsume的autoAck设置为false，并在消息处理回调函数中应答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">(consumerTag, message) -&gt; &#123;<br>  <span class="hljs-comment">//手动应答同意</span><br>  channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">//第二个参数为是否批量应答，批量应答deliveryTag当前和之前的消息。</span><br>  <span class="hljs-comment">//相当于滑动窗口的累计确认。</span><br><br>  <span class="hljs-comment">//手动应答否定</span><br>  channel.basicNack(message.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>  <span class="hljs-comment">//第三个参数为是否重新将消息放回队列。</span><br><br>  <span class="hljs-comment">//手动拒绝</span><br>  channel.basicReject(message.getEnvelope().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>  <span class="hljs-comment">//第二个参数为是否重新将消息放回队列。</span><br>  <span class="hljs-comment">//实际上为Nack的不可批量方法。</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>当存在未确认(Ack)的消息而断开了连接，消息也会重新入队。</p></blockquote><h1 id="（补充）发布确认"><a href="#（补充）发布确认" class="headerlink" title="（补充）发布确认"></a>（补充）发布确认</h1><p>通过信道的confirmSelect()方法为整条信道开启发布确认。</p><p>配合消息和队列的持久化，可以保证消息能到Broker手上且不会丢失。</p><blockquote><p>如果从交换机到队列失败了，生产者是无感知的！因为这是交换机之间的发布确认！</p></blockquote><h2 id="单个发布确认（同步-逐个确认）"><a href="#单个发布确认（同步-逐个确认）" class="headerlink" title="单个发布确认（同步+逐个确认）"></a>单个发布确认（同步+逐个确认）</h2><p>发一条消息，发送端在waitForConfirms()等方法阻塞。</p><p>当消息成功发送到Broker后，该方法将返回。</p><p>发送端的示例代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; count != <span class="hljs-number">10</span>; count++)&#123;<br>  channel.basicPublish(...);<br>  <span class="hljs-keyword">if</span> (channel.waitForConfirms())&#123;<span class="hljs-comment">/*Success*/</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="批量发布确认（同步-批量确认）"><a href="#批量发布确认（同步-批量确认）" class="headerlink" title="批量发布确认（同步+批量确认）"></a>批量发布确认（同步+批量确认）</h2><p>发送端发送若干条消息后，再waitForConfirms()方法阻塞确认多条消息，性能比上一个略高，但缺点是遇到失败无法知道是哪一条。不推荐使用。</p><p>发送端示例代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; count != <span class="hljs-number">999</span>; count++)&#123;<br>  channel.basicPublish(...);<br>  <span class="hljs-keyword">if</span> (count%<span class="hljs-number">16</span> == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//一个批次</span><br>    <span class="hljs-keyword">if</span> (channel.waitForConfirms())&#123;<span class="hljs-comment">/*Success*/</span>&#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步发布确认"><a href="#异步发布确认" class="headerlink" title="异步发布确认"></a>异步发布确认</h2><p>相比批量发布确认，在效率高的同时可以定位每一条消息发送的成功与失败并处理。</p><blockquote><p>首选</p></blockquote><p>发送端代码发送消息与上述两种同步方法相同，通常使用批量发送，但是不要紧接使用channel.waitForConfirms()进行等待，而是注册回调函数（添加监听器）。</p><blockquote><p>注意是在发送消息前注册监听器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.addConfirmListener((deliveryTag, multiple) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Confirmed.&quot;</span>);<br>&#125;, (deliveryTag, multiple) -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Not Confirmed.&quot;</span>);<br>&#125;);<br>.....<br><span class="hljs-keyword">for</span> (;;)&#123;<br>    channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;que&quot;</span>, <span class="hljs-literal">null</span>, input.getBytes(StandardCharsets.UTF_8));   <br>&#125;<br></code></pre></td></tr></table></figure><p>在异步发布确认中遇到失败时，（在监听器方法中）通常不能拿着消息重新发送一次，因此需要一些方法。</p><p>在发送消息时，我们需要使用并发容器（如ConcurrentXXX）来存放消息以在发送消息线程和监听器线程“共享”消息，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentSkipListMap&lt;Long, <span class="hljs-type">byte</span>[]&gt; messageMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>Long类型的Key实际上为DeliveryTag，通过每条消息publish后的channel.getNextPublishSeqNo()获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-type">byte</span>[] messageBody = Integer.toString(random.nextInt()).getBytes(StandardCharsets.UTF_8);<br>    channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;que&quot;</span>, <span class="hljs-literal">null</span>, messageBody);<br>    messageMap.put(channel.getNextPublishSeqNo(), messageBody);<br>&#125;<br></code></pre></td></tr></table></figure><p>完整发送端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取信道</span><br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getDefaultChannel();<br><span class="hljs-comment">//储存消息的并发容器</span><br>ConcurrentSkipListMap&lt;Long, <span class="hljs-type">byte</span>[]&gt; messageMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br><span class="hljs-comment">//监听器</span><br>channel.addConfirmListener(<br>        (deliveryTag, multiple) -&gt;<br>        &#123;<br>            <span class="hljs-comment">//批量确认</span><br>            <span class="hljs-keyword">if</span> (multiple) &#123;<br>                <span class="hljs-comment">//获取小于指定deliveryTag的消息（即批量确认前面部分的）</span><br>                ConcurrentNavigableMap&lt;Long, <span class="hljs-type">byte</span>[]&gt; multi = messageMap.headMap(deliveryTag);<br>                <span class="hljs-comment">//清除它们</span><br>                multi.clear();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//单个确认</span><br>                messageMap.remove(deliveryTag);<br>            &#125;<br>        &#125;,<br>        (deliveryTag, multiple) -&gt; &#123;<br>            <span class="hljs-comment">//打印失败的消息，通常来说你应该想办法重新发送</span><br>            System.out.println(<span class="hljs-string">&quot;Failed: &quot;</span> + deliveryTag + <span class="hljs-string">&quot;, &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(messageMap.get(deliveryTag)));<br>        &#125;<br>);<br><span class="hljs-comment">//发送消息</span><br><span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-type">byte</span>[] messageBody = Integer.toString(random.nextInt()).getBytes(StandardCharsets.UTF_8);<br>    channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;que&quot;</span>, <span class="hljs-literal">null</span>, messageBody);<br>    messageMap.put(channel.getNextPublishSeqNo(), messageBody);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="工作队列模式"><a href="#工作队列模式" class="headerlink" title="工作队列模式"></a>工作队列模式</h1><p><img src="https://www.rabbitmq.com/img/tutorials/python-two.png"></p><p>一个生产者产生“工作任务”，若干个消费者竞争（应该是轮询）获取这些“任务”。</p><h2 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h2><p>接收端和简单模式中的相同，但是建议手动应答，否则可能会出现任务全往某一个Worker上怼而其他的闲着，达不到所谓“负载均衡”的效果。</p><h2 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h2><p>发送端和简单模式中的完全相同。</p><h2 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h2><p>默认轮询分发消息是每个人都拿一条，而当消费者速度不统一时，通常为消费者设置不同的“预取量”。</p><p>通过信道的basicQos(prefetchCount)方法设置“预取量”。</p><p>当数据堆积来不及处理时，最多积压的缓冲量为“预取值”。</p><h1 id="发布订阅模式-FANOUT"><a href="#发布订阅模式-FANOUT" class="headerlink" title="发布订阅模式(FANOUT)"></a>发布订阅模式(FANOUT)</h1><p><img src="https://www.rabbitmq.com/img/tutorials/exchanges.png"></p><p>前面代码中，交换机Exchanges都使用的空字符串，实际上为AMQP Default默认交换机。并且，消息只能被一个消费者处理。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机类型有：直接（Direct）（路由模式），主题（Topic），标题（Headers），扇出（fanout）。扇出类型即发布订阅模式。</p><p>队列绑定到某个交换机，并有routingKey，交换机根据routingKey决定是否分发给某个队列。在当前模式中，通常生成随机名称的临时队列，按约定的routingKey绑定。</p><p>交换机与上面的队列一样，重复声明一样的没有问题但没声明会出事，而且声明不同配置的交换机也需要删除旧的重新声明。</p><h2 id="接收端-2"><a href="#接收端-2" class="headerlink" title="接收端"></a>接收端</h2><p>在同一个交换机下且同一个routingKey(建议为空串)下，发送端指定交换机与routingKey后所有绑定的队列都能收到消息。</p><p><del>似乎有说法是，FANOUT模式下，routingKey实际上是无效的</del></p><p>接收端绑定代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取信道</span><br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getDefaultChannel();<br><span class="hljs-comment">//声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;交换机名称&quot;</span>, BuiltinExchangeType.FANOUT);<br><span class="hljs-comment">//声明临时队列并绑定</span><br><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>channel.queueBind(queueName, <span class="hljs-string">&quot;交换机名称&quot;</span>, <span class="hljs-string">&quot;routingKey,可以为空串&quot;</span>);<br><span class="hljs-comment">//后面按正常流程接收</span><br></code></pre></td></tr></table></figure><p>channel.queueDeclare()为声明一个名称随机的临时队列，断开后队列就会销毁。</p><p>channel.queueBind(…)为绑定队列到交换机。</p><h2 id="发送端-2"><a href="#发送端-2" class="headerlink" title="发送端"></a>发送端</h2><p>发送时需要指定对应的交换机与routingKey：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取信道</span><br><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br><span class="hljs-comment">//声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;foe&quot;</span>, BuiltinExchangeType.FANOUT);<br><span class="hljs-comment">//后面按正常流程发送</span><br></code></pre></td></tr></table></figure><h1 id="路由模式-DIRECT"><a href="#路由模式-DIRECT" class="headerlink" title="路由模式(DIRECT)"></a>路由模式(DIRECT)</h1><p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png"></p><p>路由器使用Direct模式，与发布订阅模式类似，只需要在交换机声明处的Type改为BuiltinExchangeType.DIRECT。</p><p>区别只在于，不同消费者的routingKey不相同，发送者通过routingKey决定谁作为消费者（路由）。</p><p>可以一个队列绑定多个routingKey，也可以多个交换机用同一个routingKey。</p><h1 id="主题模式-TOPIC"><a href="#主题模式-TOPIC" class="headerlink" title="主题模式(TOPIC)"></a>主题模式(TOPIC)</h1><p><img src="https://www.rabbitmq.com/img/tutorials/python-five.png"></p><p>主题模式的关键在与routingKey，而routingKey的规则是一个单词列表并以符号点分割，如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">msg.<span class="hljs-keyword">info</span>.<span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>长度上限是255个字节。</p><p>接收端使用星号(*)可以代替一个单词，井号(#)可以代替零到若干个单词，实际上就是通配符，如：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>固定开头<br>abc.efg.*<br><span class="hljs-string">//</span>固定三个单词并且第二个单词为abc的<br>*<span class="hljs-string">.abc.</span>*<br><span class="hljs-string">//</span>以hibin结尾的<br><span class="hljs-comment">#.hibin</span><br><span class="hljs-string">//</span>完整匹配<br>a.b.c<br>/*<br>当指定abc.efg.hibin时，会匹配：<br>abc.efg.*<br><span class="hljs-comment">#.hibin</span><br>*/<br></code></pre></td></tr></table></figure><p>同路由模式，一样可以一队列多routingKey或多队列使用相同routingKey。</p><h2 id="发送端-3"><a href="#发送端-3" class="headerlink" title="发送端"></a>发送端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//声明主题模式交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;top&quot;</span>, BuiltinExchangeType.TOPIC);<br>...<br><span class="hljs-comment">//发送指定主题内容</span><br>channel.basicPublish(<span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;a.b.c&quot;</span>, <span class="hljs-literal">null</span>, content);<br>...<br></code></pre></td></tr></table></figure><h2 id="接收端-3"><a href="#接收端-3" class="headerlink" title="接收端"></a>接收端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//同发送端声明交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;top&quot;</span>, BuiltinExchangeType.TOPIC);<br><span class="hljs-comment">//设置监听的主题（通配或者完全匹配）</span><br>channel.queueBind(channel.queueDeclare().getQueue(), <span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;#.c&quot;</span>);<br>channel.queueBind(channel.queueDeclare().getQueue(), <span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;#.b.#&quot;</span>);<span class="hljs-comment">//绑定多个主题</span><br>...<br><span class="hljs-comment">//正常接收消息</span><br></code></pre></td></tr></table></figure><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><p><img src="/images/2022/rabbitmq_deadqueue.png"></p><p>死信指无法被消费的消息，可能是消费者发生异常、消息TTL过期、队列已满、消息被否定或拒绝且不重新入队(Reject&#x2F;Nack)，遇到死信通过死信交换机放入到死信队列中等待死信消费者后续处理（备胎）。</p><h2 id="普通队列消费者"><a href="#普通队列消费者" class="headerlink" title="普通队列消费者"></a>普通队列消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br><span class="hljs-comment">//声明普通交换机与死信交换机</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;normal_exchange&quot;</span>, BuiltinExchangeType.DIRECT);<br>channel.exchangeDeclare(<span class="hljs-string">&quot;dead_exchange&quot;</span>, BuiltinExchangeType.DIRECT);<br><span class="hljs-comment">//声明普通队列与死信队列</span><br><span class="hljs-comment">//普通队列，参数指明消息如何成为死信，以及出现死信转发到死信交换机</span><br>Map&lt;String, Object&gt; arg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">//目标的私信交换机</span><br>arg.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, <span class="hljs-string">&quot;dead_exchange&quot;</span>);<br><span class="hljs-comment">//死信RoutingKey</span><br>arg.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;dead&quot;</span>);<br><span class="hljs-comment">//过期时间，也可以在生产者设置</span><br>arg.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">1000</span>);<span class="hljs-comment">//unit ms</span><br><span class="hljs-comment">//队列长度</span><br>arg.put(<span class="hljs-string">&quot;x-max-length&quot;</span>,<span class="hljs-number">32</span>);<span class="hljs-comment">//超过长度的新消息将成为死信</span><br><span class="hljs-comment">//应用参数声明队列</span><br>channel.queueDeclare(<span class="hljs-string">&quot;normal_queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, arg);<br><span class="hljs-comment">//死信队列，处理死信的队列普普通通就好</span><br>channel.queueDeclare(<span class="hljs-string">&quot;dead_queue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//队列绑定</span><br>channel.queueBind(<span class="hljs-string">&quot;normal_queue&quot;</span>, <span class="hljs-string">&quot;normal_exchange&quot;</span>, <span class="hljs-string">&quot;normal&quot;</span>);<br>channel.queueBind(<span class="hljs-string">&quot;dead_queue&quot;</span>, <span class="hljs-string">&quot;dead_exchange&quot;</span>, <span class="hljs-string">&quot;dead&quot;</span>);<br><span class="hljs-comment">//接收</span><br>channel.basicConsume(<span class="hljs-string">&quot;normal_queue&quot;</span>, <span class="hljs-literal">true</span>,<br>        (consumerTag, message) -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Normal: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(), StandardCharsets.UTF_8));<br>        &#125;, consumerTag -&gt; System.out.println(<span class="hljs-string">&quot;Cancelled.&quot;</span>));<br></code></pre></td></tr></table></figure><p>关键在于声明队列时，设置上参数<code>x-dead-letter-exchange</code>与<code>x-dead-letter-routing-key</code>。</p><p>为了模拟，我们应该在这个消费者成功启动并创建绑定死信队列后关闭，消息应该就会去到死信消费者。</p><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p>生产者不需要在乎消费者什么死信，只管发就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br><span class="hljs-comment">//声明交换机与信道并绑定</span><br><span class="hljs-comment">//和接收端一样的重复声明不会报错，但是参数得完全一致，包括x-xxx那些，所以就不在生产者设置参数了</span><br><span class="hljs-comment">//channel.queueDeclare(&quot;normal_queue&quot;, false, false, false, null);</span><br><span class="hljs-comment">//channel.exchangeDeclare(&quot;normal_exchange&quot;, BuiltinExchangeType.DIRECT);</span><br><span class="hljs-comment">//channel.queueBind(&quot;normal_queue&quot;, &quot;normal_exchange&quot;, &quot;normal&quot;);</span><br><span class="hljs-comment">//发送消息</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; count != <span class="hljs-number">8</span>; count++) &#123;<br>    <span class="hljs-comment">//发送端设置TTL的方法</span><br>    AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder()<br>            .expiration(<span class="hljs-string">&quot;1000&quot;</span>)<span class="hljs-comment">//unit ms</span><br>            .build();<br>    <span class="hljs-comment">//发送</span><br>    channel.basicPublish(<span class="hljs-string">&quot;normal_exchange&quot;</span>, <span class="hljs-string">&quot;normal&quot;</span>, properties, <span class="hljs-string">&quot;Hi&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="死信消费者"><a href="#死信消费者" class="headerlink" title="死信消费者"></a>死信消费者</h2><p>就是一般的消费者，消费死信交换机下的死信队列即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMqUtils.getChannel();<br><span class="hljs-comment">//声明死信交换机，自信的话可以跳过</span><br><span class="hljs-comment">//channel.exchangeDeclare(&quot;dead_exchange&quot;, BuiltinExchangeType.DIRECT);</span><br><span class="hljs-comment">//声明死信队列，自信的话可以跳过</span><br><span class="hljs-comment">//channel.queueDeclare(&quot;dead_queue&quot;, false, false, false, null);</span><br><span class="hljs-comment">//队列绑定，自信的话可以跳过</span><br><span class="hljs-comment">//channel.queueBind(&quot;dead_queue&quot;, &quot;dead_exchange&quot;, &quot;dead&quot;);</span><br><span class="hljs-comment">//消费</span><br>channel.basicConsume(<span class="hljs-string">&quot;dead_queue&quot;</span>, <span class="hljs-literal">true</span>,<br>        (consumerTag, message) -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Normal: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody(), StandardCharsets.UTF_8));<br>        &#125;, consumerTag -&gt; System.out.println(<span class="hljs-string">&quot;Cancelled.&quot;</span>));<br></code></pre></td></tr></table></figure><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><p>其实就是利用了死信队列的消息TTL过期机制实现。</p><p>当正常的消费者永久消失，则总是等待设定的TTL时间后到达死信消费者。</p><p>换句话说，只有队列没有消费者，消息有TTL，那么一定超时进入到死信队列。</p><p><img src="/images/2022/rabbitmq_delayqueue_usage.png"></p><p>如图例子中就是可利用延时队列简单化问题的例子。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>RabbitMQ</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ安装与基本概念</title>
    <link href="/2022/RabbitMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/RabbitMQ%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本文只记录如何在Linux(Debian)上安装。</p><p>参考官网<a href="https://www.rabbitmq.com/install-debian.html">安装文档</a>，直接把“<a href="https://www.rabbitmq.com/install-debian.html#apt-quick-start-packagecloud">PackageCloud Quick Start Script</a>”部分的脚本复制粘贴运行即可。</p><p>在Linux上安装完成后，需要启用服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开机启动</span><br>systemctl enable rabbitmq-server<br><span class="hljs-meta prompt_"># </span><span class="language-bash">立刻启动</span><br>systemctl start rabbitmq-server<br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="管理界面开启"><a href="#管理界面开启" class="headerlink" title="管理界面开启"></a>管理界面开启</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><p>管理网页端将会在本地的15672端口上，浏览器打开即可。</p><h2 id="管理账号与密码"><a href="#管理账号与密码" class="headerlink" title="管理账号与密码"></a>管理账号与密码</h2><ul><li><p>方法一，创建新用户并设置权限组</p><ul><li><p>创建用户并设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl add_user 新用户名 新用户密码<br></code></pre></td></tr></table></figure></li><li><p>设置用户组？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl set_user_tags 刚刚创建的用户名 administrator<br></code></pre></td></tr></table></figure></li><li><p>设置用户权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl set_permissions -p / 刚刚创建的用户名 &quot;.&quot; &quot;.&quot; &quot;.*&quot;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>方法二，修改配置文件（不推荐？但是网上的教程有人用这方法的）</p><p>我发现在我的3.11.0版本的RabbitMQ上都找不到一样的文件了，就不写了。</p></li></ul><blockquote><p>默认情况下，guest&#x2F;guest只能本地登录。</p></blockquote><p>至此，你已经可以使用RabbitMQ进行开发了。</p><h1 id="RabbitMQ概念"><a href="#RabbitMQ概念" class="headerlink" title="RabbitMQ概念"></a>RabbitMQ概念</h1><p><img src="/images/2022/rabbitmq_overview.png"></p><p>RabbitMQ的5大核心概念：Connection（连接）、Channel（信道）、Exchange（交换机）、Queue（队列）、Virtual host（虚拟主机）。</p><ul><li><p>Connection（连接）</p><p>每个producer（生产者）或者consumer（消费者）要通过RabbitMQ发送与消费消息，首先就要与RabbitMQ建立连接，这个连接就是Connection。Connection是一个TCP长连接。</p><ul><li><p>Channel（信道）</p><p>Channel是在Connection的基础上建立的虚拟连接，RabbitMQ中大部分的操作都是使用Channel完成的，比如：声明Queue、声明Exchange、发布消息、消费消息等。</p><p>因为现在的程序都是支持多线程的，如果没有Channel，那么每个线程在访问RabbitMQ时都要建立一个Connection这样的TCP连接，对于操作系统来说，建立和销毁TCP连接是非常大的开销，在系统访问流量高峰时，会严重影响系统性能。</p></li></ul></li><li><p>Virtual Host（虚拟主机）</p><p>一个Broker中可以有多个虚拟主机，每个都有一套自己的Exchange和Queue，同一个Virtual host中的Exchange和Queue不能重名，不同的Virtual host中的Exchange和Queue名字可以一样。</p><p>这样，不同的用户在访问同一个RabbitMQ Broker时，可以创建自己单独的虚拟主机，然后在自己的Virtual host中创建Exchange和Queue，很好地做到了不同用户之间相互隔离的效果。</p><ul><li><p>Queue（队列）</p><p>Queue是一个用来存放消息的队列，生产者发送的消息会被放到Queue中，消费者消费消息时也是从Queue中取走消息。</p></li><li><p>Exchange（交换机）</p><p>Exchange是一个比较重要的概念，它是消息到达RabbitMQ的第一站，主要负责根据不同的分发规则将消息分发到不同的Queue，供订阅了相关Queue的消费者消费到指定的消息。</p></li></ul></li></ul><p>分发规则有：</p><ul><li><p>单收单发（简单模式）</p></li><li><p>工作队列</p></li><li><p>发布&#x2F;订阅</p></li><li><p>路由匹配</p></li><li><p>主题模式（通配符）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus备忘笔记</title>
    <link href="/2022/MyBatis-Plus%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/MyBatis-Plus%E5%A4%87%E5%BF%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>使用SpringBoot时在Maven添加Starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 这个Generator根据需要添加 --&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-generator --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>与在SpringBoot中使用Mybatis一样，在application配置文件中配置数据源即可。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-comment"># MySQL 8</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">114514</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/tutorial</span><br><br><span class="hljs-comment"># 日志</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><h1 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h1><p>声明Mapper接口并继承MyBatisPlus中的<code>BaseMapper&lt;Entity&gt;</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;My&gt;&#123;...&#125;<br></code></pre></td></tr></table></figure><p>这里My为这个Mapper主要操作的实体类。</p><p>然后在你@SpringBootApplication注解的启动类加上@MapperScan(“mapper包根目录”)</p><blockquote><p>脱裤子放屁，只需要在Mapper接口上写上@Mapper注解就行了。</p></blockquote><p>BaseMapper提供许多简单的、便利的操作功能。</p><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>MybatisPlus的偷懒魔爪伸到了业务层，但实际上和Mapper的操作差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;MyMapper,My&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyServiceIntf</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><h1 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h1><p>实体和往常一样创建一个POJO类就行，但MybatisPlus提供了一些注解。</p><blockquote><p>不要使用基本类型！</p></blockquote><ul><li>TableName</li></ul><p>对实体类，默认是类名与表名完全对应（驼峰与下划线自动转换），当不对应是需要指定实体对应表名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;normal_table&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySuperObject</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><ul><li>TableId</li></ul><p>与上述类似，当主键名称不对应可以指示（第一个参数value）。</p><p>第二个参数Type设置这个主键的生成策略，常用的有以下：</p><table><thead><tr><th align="left">策略</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">IdType.NONE</td><td align="left">默认，如果主键为空也不管，和往常一样引发异常</td></tr><tr><td align="left">IdType.AUTO</td><td align="left">当数据库设置了主键自增，那么会自己填写自增后的ID；如果数据库中没有设置，同NONE</td></tr><tr><td align="left">IdType.ASSIGN_ID</td><td align="left">不管数据库有没有设置自增，如果为空都根据雪花算法生成一个ID</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableId(&quot;normal_id&quot;,IdType.ASSIGN_ID)</span><br><span class="hljs-keyword">private</span> Long superId;<br><span class="hljs-comment">//数据库中为normal_id而代码实体类为superId,</span><br><span class="hljs-comment">//想要生成正经的ID应该使用Long，数据库使用BIGINT。</span><br></code></pre></td></tr></table></figure><ul><li>TableField</li></ul><p>与TableID基本一致，就是不用于主键。</p><ul><li>TableLogic</li></ul><p>启用逻辑删除。</p><p>在实体类某个属性（数据库表中也要有）添加，启用逻辑删除，此时Mybatis的各种操作只是将行数据（的那个属性）设置为已删除而不物理上地删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span><br><span class="hljs-keyword">private</span> Integer isDeleted;<br></code></pre></td></tr></table></figure><p>另外可以指定什么值代表已删除。</p><p><code>@TableLogic(&quot;未删除值&quot;,&quot;已删除值&quot;)</code></p><h1 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h1><p>备忘录解释那么多干什么，看<a href="https://baomidou.com/pages/10c804/#abstractwrapper">官网文档</a>！</p><p>其实就是类似于某些ORM框架，把SQL转化为有类型的、链式的方法调用，如<code>query.like(My::Name, &quot;江&quot;).gt(My::Age, 96)</code>。</p><p>条件构造器按如何区分字段可分为XxxWrapper和LambdaXxxWrapper(上面的例子就是)，按可以进行的操作可以分为QueryWrapper和UpdateWrapper。尽量使用LambdaXxxWrapper。</p><p>如果Mapper是继承了BaseMapper的话，他都会有使用条件构造器的方法，简单使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>QueryWrapper&lt;My&gt; wp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>wp.like(My::getName, <span class="hljs-string">&quot;江&quot;</span>)<br>    .gt(My::getAge, <span class="hljs-number">96</span>)<br>    .orderByAsc(My::getAge);<br>myMapper.selectList(wp);<br>...<br></code></pre></td></tr></table></figure><p>使用QueryWrapper也可以修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">My</span> <span class="hljs-variable">newMy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">My</span>();<br>...<br><span class="hljs-comment">//设置newMy的变化属性</span><br><br>QueryWrapper&lt;My&gt; wp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>wp.like(My::getName, <span class="hljs-string">&quot;江&quot;</span>)<br>    .gt(My::getAge, <span class="hljs-number">96</span>)<br>    .orderByAsc(My::getAge);<br><br>myMapper.update(newMy, wp);<br></code></pre></td></tr></table></figure><p>但修改的正统方法是通过UpdateWrapper:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">UpdateWrapper&lt;My&gt; wp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;&gt;();<br>wp.like(My::getName, <span class="hljs-string">&quot;江&quot;</span>)<br>    .gt(My::getAge, <span class="hljs-number">96</span>)<br>    .orderByAsc(My::getAge)<br>    .set(My::getAge, <span class="hljs-number">95</span>)<br>    .set()<br>    ...<br>myMapper.update(<span class="hljs-literal">null</span>, wp);<br></code></pre></td></tr></table></figure><p>子查询可以通过<code>.inSql()</code>或<code>.notInSql()</code>方法判断是否在子查询集合。</p><p>需要根据条件开关Wrapper某个小条件，注意到condition参数。</p><h1 id="自带的分页插件"><a href="#自带的分页插件" class="headerlink" title="自带的分页插件"></a>自带的分页插件</h1><p>MybatisPlus的插件的添加方法都是通过配置类（本文是SpringBoot！）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这段代码添加的就是分页插件！</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>        interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>(DbType.你的数据库类型));<br>        <span class="hljs-keyword">return</span> interceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义Page实体，决定范围，类似但不同于limit ?,?</span><br>Page&lt;My&gt; toPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(从<span class="hljs-number">1</span>起的页数不是INDEX, 每页多少条);<br><span class="hljs-comment">// 设置查询条件</span><br>QueryWrapper&lt;My&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>wrapper.like(My::getName, <span class="hljs-string">&quot;江&quot;</span>);<br><span class="hljs-comment">// 执行查询，用IPage来接收</span><br>IPage&lt;My&gt; iPage = myMapper.selectPage(toPage, wrapper);<br><span class="hljs-comment">//实际上你后面直接用toPage也可以！</span><br><span class="hljs-comment">// 查看分页信息</span><br>System.out.println(<span class="hljs-string">&quot;当前页：&quot;</span> + iPage.getCurrent());<br>System.out.println(<span class="hljs-string">&quot;总页数：&quot;</span> + iPage.getPages());<br>System.out.println(<span class="hljs-string">&quot;每一页显示的条数：&quot;</span> + iPage.getSize());<br>System.out.println(<span class="hljs-string">&quot;总条数：&quot;</span> + iPage.getTotal());<br><span class="hljs-comment">// 分页后的数据列表</span><br><span class="hljs-keyword">return</span> iPage.getRecords();<br></code></pre></td></tr></table></figure><p>自定义查询中也可以使用这个分页插件，只需要第一个参数为Page，SQL中不需要写limit之类的。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-Plus</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring核心与MVC笔记</title>
    <link href="/2022/Spring%E6%A0%B8%E5%BF%83%E4%B8%8EMVC%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/Spring%E6%A0%B8%E5%BF%83%E4%B8%8EMVC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在已经很少有新项目不使用SpringBoot而使用基础的、原始的Spring框架以及SpringMVC，但SpringBoot又会需要这些“老东西”的概念，故重新整理SpringBoot的“前辈”相关笔记并合并，主要还是对概念的记录。</p><h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><blockquote><p>IOC意为控制反转，简单理解为将对象的创建(new)行为由程序员转为由容器执行，程序员只需要在任意要用的地方“注入”。</p></blockquote><h4 id="基于注解定义Bean"><a href="#基于注解定义Bean" class="headerlink" title="基于注解定义Bean"></a>基于注解定义Bean</h4><blockquote><p>因为只是记录原理，故不记录如何在配置文件中启用Bean扫描。</p><p>因为现在新项目或者有头脑的Leader迁移到SpringBoot之后基本不会去单独使用这原始的Spring。</p></blockquote><ul><li><p>定义Bean</p><ul><li>在类前加上注解@Component, @Service, @Controller, @Repository<br>四者功能相同，日后可能不同，并且用于约定区分不同类型的Bean并且用于过滤器过滤。</li></ul><ul><li><p>使用@Scope设定作用域：</p><ul><li><p>singleton</p><p>默认的scope，表示单例模式。</p></li><li><p>prototype</p><p>一般的new模式，适合有状态要独立的Bean。</p></li><li><p>request</p><p>类似prototype但只在每个http请求（线程或控制器）中独立的。</p></li><li><p>session</p><p>类似prototype但只在每个会话（线程或控制器）中独立的。</p></li></ul></li></ul></li><li><p>注入</p><ul><li><p>构造函数注入</p><p>类前添加了Bean声明注解的，构造函数会自动注入类所需成员。</p></li><li><p>Setter注入</p><p>在成员的Setter方法前添加@Autowired，将会注入。</p></li><li><p>直接注入</p><p>在类的成员变量上添加<del>@Autowired</del>或@Resource，将会注入。</p></li></ul></li><li><p>参数注入</p><ul><li><p>固定参数注入</p><p>在类成员变量上添加@Value注解</p></li><li><p>配置文件参数注入</p><p><em>别问为什么没用也别学</em></p></li></ul></li></ul><blockquote><p>XML配置方式繁杂且基本不会去使用，故不记录</p></blockquote><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote><p>面向切面编程，简单理解为在某个类的某个方法执行的前、后等时刻基于额外操作，也能够拦截传入的参数。</p><p>使用得并不多，但很有用。</p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>后面所说的通知类，指通常所说的代理Proxy类</strong></p><ul><li><p>连接点：类中可以被增强（代理）的方法</p></li><li><p>切入点：实际上被增强的连接点</p></li><li><p>通知：增强部分的代码</p><ul><li>前置通知、后置通知：方法执行前或后的增强</li><li>环绕通知：前和后都增强</li><li>异常通知：出现异常时处理</li><li>最终通知：无论如何都会最后执行的（try后的finally</li></ul></li><li><p>切面：把通知应用到切入点的过程（织入、执行</p></li></ul><h4 id="基于注解使用AOP"><a href="#基于注解使用AOP" class="headerlink" title="基于注解使用AOP"></a>基于注解使用AOP</h4><blockquote><p>不使用SpringBoot的话，实际上需要在配置文件中开启扫描，忽略同上。</p><p>但在SpringBoot中使用AOP要另外引入Starter！</p></blockquote><ul><li><p>通知类前添加@Aspect注解</p><p>同时，通知类与要增强的类（AOP受体）均要为Bean。</p></li><li><p>通知方法前加上注解</p><table><thead><tr><th>注解</th><th>用途</th></tr></thead><tbody><tr><td>@Before</td><td>前置通知，在连接点前执行</td></tr><tr><td>@AfterReturning</td><td>连接点正常执行后通知，没有抛出错误时执行</td></tr><tr><td>@AfterThrowing</td><td>连接点抛出错误时执行</td></tr><tr><td>@After</td><td>无论有没有抛出错误都在连接点结束后执行(finally)</td></tr><tr><td>@Around</td><td>在@Before前和没有抛出错误结束后都执行</td></tr></tbody></table></li><li><p>通知方法的顺序</p><p>@Around前 –&gt;</p><p>@Before –&gt; </p><p>切入点（本体）–&gt; </p><p>@AfterReturning&#x2F;@AfterThrowing –&gt;</p><p>@Around后</p><p><em>不同版本可能会有不同</em></p></li><li><p>通知的参数语法（切入点选择）</p><ul><li>execution(* 包.类.方法(参数类型表))<br>指定为这个方法</li><li>execution(* 包.类.*(..两个点表示任意))<br>指定为这个类的所有方法</li><li>execution(* 包.<em>.</em>(..))<br>指定为这个包下所有类的所有方法（当然也可指定所有类的某个方法</li><li>execution(* 包..<em>.</em>(..))<br>在上一个的基础上，一同搜索子包里的</li><li>execution(* *A(..))<br>所有以“A”结尾的方法</li><li>within(包.*)<br>包内的所有接入点，也可双点搜索子包<br>Spring AOP Only</li><li>this&#x2F;target(接口全路径)<br>实现了这个接口的类的接入点<br>this: 匹配不到被重写了的接口中的方法<br>target: 全部</li><li>相关功能注解<ul><li>@Target(注解类)<br>同target execution用法</li><li>@Annotation(注解类)<br>所有含有这个注解的方法（接入点）</li><li>@Within(注解类)<br>同this execution用法</li><li>@Order(优先级，小的优先)<br>多个通知同时作用于一个切入点时控制通知链的内部的顺序</li></ul></li><li>抽取公共（复用）切入点<br>在通知类中对某个方法使用@Pointcut选择切入点，其他通知的参数写上该方法名</li></ul></li></ul><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><blockquote><p>简化了万恶的Servlet。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>工作流程如图:</p><ol><li>当接收到用户的请求时，请求进入到DispatcherServlet进行处理</li><li>DispatcherServlet根据请求的URL从HandlerMapping获取映射的处理请求的Bean，也就是Controller</li><li>通过HandlerAdapter调用Controller（应该是适配处理了数据转换），Controller内部处理业务</li><li>Controller返回ModelAndView（Model相当于请求响应参数，View是指定要跳转的视图）</li><li>ViewResolver根据返回的指定的View（可能没有）进行跳转</li></ol><p><img src="/images/2022/springmvc.jpg"></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>同上述IOC、AOP中的情况，SpringMVC配置一样很繁琐，甚至还要依赖web.xml，现在已经没有多少项目使用（就是使用你也不怎么用动配置文件或者百度一下就能轻松知道。</p><p><strong>用配置文件配置控制器已经要被扫进垃圾桶辣！</strong></p><h4 id="通过注解实现控制器"><a href="#通过注解实现控制器" class="headerlink" title="通过注解实现控制器"></a>通过注解实现控制器</h4><ul><li><p>类加上注解@RestController</p><ul><li>相当于@Controller + @ResponseBody</li><li>@ResponseBody表示这个方法返回的字符串直接写到响应内容</li></ul></li><li><p>控制器类的每个http接口需要@RequestMapping, @GetMapping, @PostMapping等</p></li></ul><h4 id="返回数据与重定向"><a href="#返回数据与重定向" class="headerlink" title="返回数据与重定向"></a>返回数据与重定向</h4><ul><li>RestController的return直接返回对应数据给前端</li></ul><ul><li><p>数据与重定向（ModelAndView）</p><ul><li>返回值的ModelAndView将Model（给View的数据）和View（指定跳转的视图）返回给DispatcherServlet（经Adapter）</li><li>ModelAndView通过.addObject()等方法添加参数（类似基本Servlet向请求或响应中setAttribute），通过.setViewName()指定跳转的视图</li><li>如果需要Model则在方法参数列表声明(org.springframework.ui.)Model变量<br>返回字符串的方法会将Model转发</li><li>参数列表的ModelMap<br>与Model或ModelAndView相比就是个HashMap和简化出常用方法的区别</li></ul></li><li><p>直接重定向  （非RestController）<br>若没有在XML或配置类中配置ViewResolver，实际上能够在return视图的名称时直接指定，也可以使用前缀指定是转发还是重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//转发</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/your-path/page.jsp&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/sbv/sss.jsp&quot;</span>;<br><span class="hljs-comment">//重定向</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/aaaa.jsp&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>转发是指带着请求的参数到下一个地方去</li><li>重定向是客户端浏览器自己进行跳转的行为（相当于用户自己重新访问新页面<br>重定向无法访问WEB-INF</li></ul></li></ul><h4 id="传入的HTTP参数"><a href="#传入的HTTP参数" class="headerlink" title="传入的HTTP参数"></a>传入的HTTP参数</h4><ul><li><p>一般参数传入，非Restful(…&#x2F;method?param&#x3D;value&amp;…)</p><ul><li><p>获取参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/echo&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;<br></code></pre></td></tr></table></figure><p>中，当使用”…&#x2F;echo?msg&#x3D;xxx”访问时能正确获得msg参数。</p></li><li><p>当url中参数名和方法参数表变量名不一致时，可在方法参数前加@RequesParam(“url中的实际名称”)来指定，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/echo&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;message&quot;)</span> String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;<br></code></pre></td></tr></table></figure><p>此时使用”…&#x2F;echo?message&#x3D;xxx”访问能正确填充msg。</p></li><li><p>组成成对象</p><p>当传入的参数可以组成一个类（并且名字与类属性一一对应）时，可以直接把类写到参数，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/echo&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">User: int id; string name;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>此时使用”…&#x2F;echo?id&#x3D;xxx&amp;name&#x3D;xxx”访问能正确填充user。</p></li></ul></li><li><p>Restful参数传入</p><ul><li><p>HTTP接口方法可在参数列表使用@PathVariable获取url参数。</p><p>@RequestMapping中需要注明参数名像：</p><p><code>@RequstMapping(&quot;/map/&#123;varA&#125;/&#123;varB&#125;&quot;)  </code><br>然后对参数表中的参数注解如：</p><p><code>@PathVariable(&quot;varA&quot;) String bbb</code></p></li><li><p>如果RequestMapping中的参数名称和方法参数表得到相同可省略@PathVariable的参数。</p></li><li><p>@RequestMapping中可以指定method为GET&#x2F;PUT&#x2F;POST&#x2F;DELETE，或直接使用@GetMapping&#x2F;@PostMapping等。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL免安装版安装与配置(Windows)</title>
    <link href="/2022/MySQL%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E9%85%8D%E7%BD%AE(Windows)/"/>
    <url>/2022/MySQL%E5%85%8D%E5%AE%89%E8%A3%85%E7%89%88%E9%85%8D%E7%BD%AE(Windows)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文为在Windows系统上安装，因为通常Windows会需要这样安装。</p></blockquote><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>从MySQL下载社区（GPL）版本，<a href="https://dev.mysql.com/downloads/mysql/">链接</a>。</p><p>下载完成后解压到合适的目录，如下结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">591M    ./bin<br>14K     ./docs<br>416K    ./include<br>265M    ./lib<br>9.9M    ./share<br>1.1G    .<br></code></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>如果想要更改如服务器端口等设置，可在&#x2F;bin目录下创建和编辑my.ini文件。</p><p>这是抄的（直球），事实上一般使用无需配置！</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><br><span class="hljs-comment"># 解决无法写入空时间，解除严格限制模式</span><br><span class="hljs-attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES <br><span class="hljs-attr">table_definition_cache</span>=<span class="hljs-number">400</span><br><span class="hljs-attr">table_open_cache</span>=<span class="hljs-number">256</span><br><span class="hljs-comment"># 服务端使用的字符集默认为utf8mb4</span><br><span class="hljs-attr">character_set_server</span>=UTF8MB4<br><span class="hljs-comment">#时间设置，这里设置的是北京时间</span><br><span class="hljs-attr">default-time-zone</span>=<span class="hljs-string">&#x27;+08:00&#x27;</span><br><span class="hljs-comment">#设置大小写是否敏感的一个参数</span><br><span class="hljs-attr">lower_case_table_names</span>=<span class="hljs-number">2</span><br><span class="hljs-comment">#mysql默认安装目录（需要改成对应的路径）</span><br><span class="hljs-attr">basedir</span>=C:\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">15</span>-winx64<br><span class="hljs-comment">#数据库的数据的存储地址（需要改成对应的路径）</span><br><span class="hljs-attr">datadir</span>=C:\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">15</span>-winx64\data<br><span class="hljs-comment">#错误日志（需要改成对应的路径）</span><br><span class="hljs-attr">log-error</span>=C:\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">15</span>-winx64\log\err.log<br></code></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>如果需要在任何位置控制台启动mysql，则把bin添加到环境变量。</p><p>不用我教了吧！个人也觉得没什么必要！</p><h3 id="注册Windows服务"><a href="#注册Windows服务" class="headerlink" title="注册Windows服务"></a>注册Windows服务</h3><ul><li><p><em>确保控制台有管理员权限！</em>* </p></li><li><p>进入&#x2F;bin目录，运行<code>mysqld.exe --install</code>，你可能需要按Tab键将mysqld.exe自动补全为.\mysqld.exe。</p><p>此操作为安装Windows服务，如果需要卸载，运行<code>mysqld.exe --remove mysql</code>。</p><p>成功输出<code>Service successfully installed.</code>。</p></li><li><p>仍然在&#x2F;bin目录，运行<code>mysqld.exe --initialize --console</code>，进行初始化。</p><p>成功后后见到日志打印临时密码如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">09</span>-<span class="hljs-number">05</span>T08:<span class="hljs-number">30</span>:<span class="hljs-number">47</span>.<span class="hljs-number">539192</span>Z <span class="hljs-number">6</span><span class="hljs-meta"> [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: eihdeyQ)Z5,Z </span><br></code></pre></td></tr></table></figure><p>复制保存。</p></li><li><p>你可能需要<code>net start mysql</code>启动服务。</p></li><li><p>通过<code>mysql -u root -p</code>并输入临时密码登录后，你需要修改密码。</p><p>修改密码使用 <code>alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;114514&#39;;</code>。</p><p>如果提示密码不符合安全策略，请百度对应方法，我一直没遇到。</p></li></ul><h1 id="服务的启动与关闭"><a href="#服务的启动与关闭" class="headerlink" title="服务的启动与关闭"></a>服务的启动与关闭</h1><blockquote><p>让MySQL的服务开机自启是非常蠢的</p></blockquote><ul><li><p>将服务启动设置为手动</p><p>在 Windows开始菜单&#x2F;Windows管理工具&#x2F;服务 中找到MySQL的服务将其设置为手动启动。</p></li><li><p>使用<code>net start mysql</code>启动，使用<code>net stop mysql</code>停止。需要管理员权限。</p></li><li><p>可以将启动和停止命令保存为.bat文件，以便右键管理员运行。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACME申请免费SSL证书</title>
    <link href="/2022/ACME%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6/"/>
    <url>/2022/ACME%E7%94%B3%E8%AF%B7%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么需要ACME"><a href="#为什么需要ACME" class="headerlink" title="为什么需要ACME"></a>为什么需要ACME</h1><p>不使用SSL（HTTPS），或者使用某些奇怪机构签发的SSL证书，将使你处于裸奔和被限制的情况当中。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><em>ACME通常运行在Linux上。</em></p><p>在Github上你在<a href="https://github.com/acmesh-official/acme.sh/">对应仓库</a>可以下载到安装脚本，并看到与本文类似的文档，本文只是总结。</p><p>我们需要把ACME安装到系统中，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl  https://get.acme.sh | sh -s email=my@example.com<br></code></pre></td></tr></table></figure><p>将会把acme.sh这一核心文件存放到~&#x2F;.acme.sh&#x2F;并配置自动任务和邮箱。</p><p>你可以将命令拆分执行，并更改install.sh中的github地址为Github Proxy或镜像的地址。</p><p>在下面生成证书的过程中，会用到socat，因此最好先使用包管理器安装socat。</p><h1 id="生成证书（老方法）"><a href="#生成证书（老方法）" class="headerlink" title="生成证书（老方法）"></a>生成证书（老方法）</h1><p>你可以直接生成证书到某个web网站的根目录，通常配合宝塔或其他web容器使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh  --issue  -d mydomain.com -d www.mydomain.com  --webroot  /home/wwwroot/mydomain.com/<br></code></pre></td></tr></table></figure><p>ACME也能智能地配置apache或nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh --issue  -d mydomain.com   --nginx<br></code></pre></td></tr></table></figure><p>当然，最常用的还是直接生成证书，自己决定证书的使用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">acme.sh  --issue -d mydomain.com   --standalone<br></code></pre></td></tr></table></figure><p>因此，你可以发现，acme使用<code>--issue</code>来进行证书申请，<code>-d</code>指定域名，如<code>--standalone</code>的是acme配置的方法。</p><p>生成的证书会在过期时自动更新。</p><p><strong>注意：</strong></p><p>由于ACME的原理是在80或其他自定义端口上放置验证文件，并通过http方式访问验证，在ACME某次更新后由原本的使用ip地址访问改为了使用你想要注册的域名访问，此方法在限制之下已经失效。</p><h1 id="生成证书（新方法）"><a href="#生成证书（新方法）" class="headerlink" title="生成证书（新方法）"></a>生成证书（新方法）</h1><p>方法来自<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">文档</a>，内有更多DNS的方法。</p><p>这里建议使用CF，但注意不要开启流量代理，不然基本跑不动。</p><p>我们需要拿到CF的Key以让ACME可以通过CF自动配置：</p><ol><li>进入CF，右上角个人头像图标下拉菜单中找到“我的个人资料”。</li><li>左侧找到“API令牌”。</li><li>你需要生成或查看Global API Key。</li><li>临时记录下这个Key。</li></ol><p>之回到服务器，我们可以开始申请：</p><ol><li>把刚刚的Key和CF账号的邮箱添加到环境变量 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export CF_Key=&quot;CF里的Global API Key&quot;<br>export CF_Email=&quot;CF账号的邮箱&quot;<br></code></pre></td></tr></table></figure></li><li>申请 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./acme.sh --issue --dns dns_cf -d example.com -d www.example.com<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装使用各种包管理器没有的版本的JDK</title>
    <link href="/2022/Linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%90%84%E7%A7%8D%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E6%B2%A1%E6%9C%89%E7%9A%84%E7%89%88%E6%9C%AC%E7%9A%84JDK/"/>
    <url>/2022/Linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%90%84%E7%A7%8D%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E6%B2%A1%E6%9C%89%E7%9A%84%E7%89%88%E6%9C%AC%E7%9A%84JDK/</url>
    
    <content type="html"><![CDATA[<h2 id="下载你需要的版本的JDK"><a href="#下载你需要的版本的JDK" class="headerlink" title="下载你需要的版本的JDK"></a>下载你需要的版本的JDK</h2><p>网上有许多预编译的OpenJDK，我选择的是<a href="https://adoptium.net/">Adoptium</a>的Temurin。</p><p>文件可以解压到任何稳定安全的文件夹中，但是建议放在<code>/usr/lib/jvm/</code>，因为包管理器的JDK也是放到这里。</p><p>解压好的目录像这样：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crystal">/usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">jvm</span>/</span><br>└── jdk8u322<br>    ├── bin<br>    ├── <span class="hljs-keyword">include</span><br>    ├── jre<br>    ├── <span class="hljs-class"><span class="hljs-keyword">lib</span></span><br>    ├── man<br>    └── sample<br></code></pre></td></tr></table></figure><p>反正能访问到就行。</p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>只介绍永久生效的配制方法。</p><p>在文件<code>/etc/profile</code>的末尾添加：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/lib/jvm/jdk8u322/<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$JAVA_HOME</span>/jre<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/lib<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$JAVA_HOME/bin:$JRE_HOME/bin<br></code></pre></td></tr></table></figure><p>根据你的实际情况修改路径。</p><p>保存文件后，还需要重新加载才能生效，使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>即可。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用这种方法安装JDK，你最好卸载掉包管理器中的版本。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于HEXO在GITHUB PAGE建立简单博客</title>
    <link href="/2022/%E5%9F%BA%E4%BA%8EHEXO%E5%9C%A8GITHUB-PAGE%E5%BB%BA%E7%AB%8B%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/%E5%9F%BA%E4%BA%8EHEXO%E5%9C%A8GITHUB-PAGE%E5%BB%BA%E7%AB%8B%E7%AE%80%E5%8D%95%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你不想折腾，那么托管WordPress是最好的选择。</p><p>HEXO不止可以部署到Github Pages，因为其本质是通过Markdown生成静态页面，所以任何你想到的网页容器都行。</p><p>WordPress虽然一站式解决，但是安装很麻烦，故我选择了HEXO。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>HEXO基于Node.js，建议使用nvm（或nvm-windows）安装，方便管理各种版本的node.js。</p><p>在nvm中安装管理node.js版本请看别的教程。</p><p>然后安装HEXO：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>到达你要放置博客的文件夹，通过</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo init<br></code></pre></td></tr></table></figure><p>建立博客的“脚手架”，当然也可以</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo init new_dir<br></code></pre></td></tr></table></figure><p>创建一个文件夹并建立“脚手架”。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>博客根目录下的_config.yml有博客的基本设置，如标题、主题等。</p><p>详细的配置，还是看<a href="https://hexo.io/zh-cn/docs/configuration">HEXO官方文档</a>比较方便。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>虽然许多主题作者都开始转向使用npm来分发主题，但这里还是建议手动解压主题文件到themes文件夹。这样一来问题会少一些。</p><p>一般而言，你只需要下载主题压缩包，解压到themes&#x2F;，然后在博客根目录新建或重命名一个_config.主题名称.yml文件，最后更改_config.yml中的theme即可。</p><p>通常_config.主题名称.yml文件是对主题额外的东西的设置。</p><p>热门的主题都有对应的详尽的安装方法。</p><h2 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h2><p>可以通过</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new post[/draft/page] <span class="hljs-string">&#x27;新的标题&#x27;</span><br></code></pre></td></tr></table></figure><p>来创建新的文件，新的文件在博客根目录下的source&#x2F;_posts，你也可以自己创建。</p><p>一个新文件的头部通常是这样的：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">---<br>title: 文章标题<br>date: 时间，如 2021-08-08 21:27:14<br>tags: [标签, 标签数组的第二个, 等等等等等等]<br>categories: [分类, 子分类]<br>---<br></code></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>这里只介绍使用GITHUB PAGES的方法，即HEXO文档中的<a href="https://hexo.io/zh-cn/docs/one-command-deployment#Git">Git部署</a>方法。</p><p>需要安装依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><blockquote><p>–save、-S参数意思是把模块的版本信息保存到dependencies（生产环境依赖）中，即你的package.json文件的dependencies字段中</p></blockquote><p>然后编辑_config.yml，找到deploy项，改成如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">deploy:<br>  type: &#x27;git&#x27;<br>  repo: 浏览器中的仓库网页地址，如https://github.com/Sodacooky/sodacooky.github.io<br>  branch: gh-pages<br>  message: deploying<br></code></pre></td></tr></table></figure><p>其中，branch为push的分支，【一定】不要是本来存放博客内容的“脚手架”的分支，deploy将会把并且只会把编译（生成）好的前端静态页面push到这个分支。</p><p>还要在Github仓库中，在Settings -&gt; Pages -&gt; Source中把Branch改为你上面设置的分支。</p><p>最后，在你通过<code>hexo new</code>创建文件，<code>hexo clean</code>清理生成缓存（可选），<code>hexo generate</code>生成静态文件后，你就可以</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo deploy<br></code></pre></td></tr></table></figure><p>将更新部署到Github，等待一下就生效。</p><h2 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h2><p>就在上面设置分支时，你会看到一个Custom domain，如果你直接在那里添加，只会在远程仓库中的指定分支中创建一个CNAME文件，下次push就会失效。</p><p>你应该在博客根目录的source文件夹中，放入这个CNAME文件，内容是你的域名。</p><p>记得先在DNS添加CNAME记录。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HEXO</tag>
      
      <tag>博客</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>飞机脑袋全家桶评测方法</title>
    <link href="/2022/%E9%A3%9E%E6%9C%BA%E8%84%91%E8%A2%8B%E5%85%A8%E5%AE%B6%E6%A1%B6%E8%AF%84%E6%B5%8B%E6%96%B9%E6%B3%95/"/>
    <url>/2022/%E9%A3%9E%E6%9C%BA%E8%84%91%E8%A2%8B%E5%85%A8%E5%AE%B6%E6%A1%B6%E8%AF%84%E6%B5%8B%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>使用Eval Reset插件的时代已经被打开必须登录或者Act结束了。</p><p>插件作者本人带来了新的方法：Java Agent</p><h2 id="下载ja-netfilter"><a href="#下载ja-netfilter" class="headerlink" title="下载ja-netfilter"></a>下载ja-netfilter</h2><p>前往<a href="https://jetbra.in/s">神奇的网站</a>，在网页顶部下载一份额外为飞机脑袋全家准备的ja-netfilter。</p><blockquote><p>2022.6.1更新后，神奇的网站变成了一个各个神奇网站的列表，选择一个可用的即可。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>将下载的压缩包解压到一个方便的地方。</p><p>如果你有能力，剩下的看readme.txt就可以了。</p><h2 id="准备评测"><a href="#准备评测" class="headerlink" title="准备评测"></a>准备评测</h2><h3 id="自动脚本"><a href="#自动脚本" class="headerlink" title="自动脚本"></a>自动脚本</h3><p>在这个神奇的目录下有个文件夹<code>scripts</code>，运行里面的<code>install-xxx-user.vbs</code>也可以实现上面手动的效果，就是等比较久。</p><h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a><del>手动配置</del></h3><p>我们需要找到软件的vmoptions文件。</p><p>如果是Windows，通常在</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">C:</span>\Users\你的用户名\AppData\Roaming\JetBrains\对应的软件<br></code></pre></td></tr></table></figure><p>目录下，会有对应软件的vmoptions文件，如webstorm64.exe.vmoptions。</p><p>如果没有，则手动创建，上一步中解压出来的文件里的vmoptions文件夹就有预设的。</p><p>把</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-javaagent:ja-netfilter.jar文件的绝对路径=jetbrains</span><br></code></pre></td></tr></table></figure><p>加到vmoptions文件中。</p><h2 id="开始评测"><a href="#开始评测" class="headerlink" title="开始评测"></a>开始评测</h2><p>打开你的JB软件，激活。</p><p>如果使用码，在那个<a href="https://jetbra.in/s">神奇的网站</a>复制一个。</p><p><del>如果使用服务器，那么填上<code>https://jetbra.in</code>即可。</del>(2022.6.1后不可用)</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JetBrains</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot笔记</title>
    <link href="/2022/SpringBoot/"/>
    <url>/2022/SpringBoot/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>Maven包含了SpringBoot的各种依赖<br>用户只需要引入启动器(<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">spring-boot-starter-xxx</a>)，版本被依赖管理（父项目）<br>当然，不能这样引入的、偏僻的包也可以用老方法引入</li></ul><h2 id="自动配置-SpringBootApplication"><a href="#自动配置-SpringBootApplication" class="headerlink" title="自动配置 @SpringBootApplication"></a>自动配置 @SpringBootApplication</h2><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h4><p>该注解将类注册为Bean并标注为SpringBoot应用（启动类）  </p><h4 id="其内main方法内的SpringApplication-run-启动类-class-args-将该应用启动"><a href="#其内main方法内的SpringApplication-run-启动类-class-args-将该应用启动" class="headerlink" title="其内main方法内的SpringApplication.run(启动类.class,args)将该应用启动"></a>其内main方法内的SpringApplication.run(启动类.class,args)将该应用启动</h4><ol><li>推断程序是否为Web项目，设置监听器，设置main方法定义类（设置主类）</li><li>获取配置参数(核心配置文件、banner.txt等)</li><li>配置上下文、装配Bean等</li></ol><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>SpringBoot配置，是@Configuration修饰的@Component的组件</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>自动配置，将启动类下的所有包的东西导入    </p><ul><li>@AutoConfigurationPackage<br>通过@Import({Registrar.class})，<br>将@SpringBootApplication注解的主程序类所在包及其子包下的“组件”扫描注册到Spring容器。</li><li>@Import({AutoConfigurationImportSelector.class})<br>查找classpath中所有jar包的META-INF&#x2F;spring.factories进行加载，选择性地将配置信息交给Spring容器进行创建。</li></ul><h4 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h4><p>@SpringBootApplication注解让Spring在启动时自动将maven导入了的starter（各种模块）加载，也把启动类目录之下的所有东西加载。</p><hr><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><ul><li>官网Spring Initilizer</li><li>IDEA内置Spring Initilizer</li><li>需要勾选组件SpringWeb（内嵌Tomcat等）<br>通常还需要commons-io与commons-fileupload包</li></ul><h2 id="application-properties-yml"><a href="#application-properties-yml" class="headerlink" title="application.properties&#x2F;yml"></a>application.properties&#x2F;yml</h2><p><em>SpringBoot的核心配置文件</em></p><h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><ul><li>server.port&#x3D;容器端口号<br>或yml<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-string">端口号</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="YAML语法-一定记得空格"><a href="#YAML语法-一定记得空格" class="headerlink" title="YAML语法 一定记得空格"></a>YAML语法 <em>一定记得空格</em></h4><ul><li>普通KV<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">key:</span> <span class="hljs-string">value</span><br></code></pre></td></tr></table></figure></li><li>对象<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">object:</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">kkey:</span> <span class="hljs-number">2022</span><span class="hljs-string">/01/01</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">object:</span> &#123;<span class="hljs-attr">key:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">kkey:</span> <span class="hljs-number">14514</span>&#125;<br></code></pre></td></tr></table></figure></li><li>数组<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#行内</span><br><span class="hljs-attr">object:</span> [<span class="hljs-string">阿黄</span>, <span class="hljs-string">阿龙</span>]<br><span class="hljs-comment">#多行</span><br><span class="hljs-attr">object:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">value</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">vvalue</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="YAML能直接给实体类赋值（注入）"><a href="#YAML能直接给实体类赋值（注入）" class="headerlink" title="YAML能直接给实体类赋值（注入）"></a>YAML能直接给实体类赋值（注入）</h4><p><em>类似于XML配置文件注入或@Value</em></p><ol><li>在配置文件中按上述类的语法写好</li><li>要注入的类加上注解@ConfiguratrionProperties(prefix&#x3D;”配置文件中的对象名”)</li></ol><ul><li><del>加载指定配置文件</del><br>@PropertySource(“classpath:xxx”)<br>@Value(“${key}”)</li></ul><h4 id="多配置"><a href="#多配置" class="headerlink" title="多配置"></a>多配置</h4><ul><li>多文件<ol><li>可以在SpringBoot支持的目录下，保存各种名为application-xxx.yml文件</li><li>在默认的，最高优先级的配置文件中通过spring.profiles.active指定上面的xxx</li></ol></li><li>单文件<ol><li>在默认位置的配置文件中，用三个横杠<code>---</code>分割各个配置<br><del>不同的配置中，spring.profiles来命名</del>  </li><li>不同配置使用:  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>    <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">activate:</span><br>        <span class="hljs-attr">on-profile:</span> <span class="hljs-string">xxx</span><br></code></pre></td></tr></table></figure>命名区分  </li><li>选择方式同多文件，卸载没有命名的、默认的配置中</li></ol></li></ul><h4 id="更换banner"><a href="#更换banner" class="headerlink" title="更换banner"></a>更换banner</h4><p>resources目录下的banner.txt</p><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>默认没有配置则按：classpath:resources &gt; classpath:static &gt; classpath:public 顺序<br>配置方法为spring.web.resources.static-locations: file:xxxx<br>静态资源映射为spring.mvc.static-path-pattern&#x3D;URL格式，如&#x2F;res&#x2F;**则&#x2F;res&#x2F;img.jpg访问  </p><blockquote><p>  放在templates目录下的，在模板引擎的支持下只能通过Controller的View进入，类似WEB-INF</p></blockquote><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>SpringBoot内置Tomcat只支持jks和pkcs12格式的密钥<br>转换方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl pkcs12 -<span class="hljs-built_in">export</span> -<span class="hljs-keyword">in</span> xxx.pem/cer -inkey xxx.pem/key -out xxx.p12<br></code></pre></td></tr></table></figure><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">ssl:</span><br>    <span class="hljs-attr">key-store:</span> <span class="hljs-string">密钥文件路径</span><br>    <span class="hljs-attr">key-store-type:</span> <span class="hljs-string">pkcs12/jks</span><br>    <span class="hljs-attr">key-store-password:</span> <span class="hljs-string">创建或转换时输入的口令</span><br></code></pre></td></tr></table></figure><h4 id="首页与图标定制-类似welcome-page"><a href="#首页与图标定制-类似welcome-page" class="headerlink" title="首页与图标定制(类似welcome-page)"></a>首页与图标定制(类似welcome-page)</h4><ul><li>首页index.html默认能放在上述的静态资源目录中</li><li>网站图标favicon.ico放在静态资源目录下(旧版本还需spring.mvc.favicon.enabled&#x3D;false</li></ul><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="数据校验-JSR303"><a href="#数据校验-JSR303" class="headerlink" title="数据校验 JSR303"></a>数据校验 JSR303</h4><ul><li>通常对POJO类使用，限制数据的内容。如限制为邮箱或符合某正则表达式的字符串。</li><li>如@NotNull, @Size, @Pattern等</li></ul><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p><strong>SpringSecurity方式</strong><br>需要导入依赖 spring-boot-starter-security  </p><ol><li>编写类继承WebSecurityConfigurerAdapter并@EnableWebSecurity</li><li>配置页面权限<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    http.authorizeRequests()<br>    .antMatchers(<span class="hljs-string">&quot;请求名称&quot;</span>)<br>    .hasRole(<span class="hljs-string">&quot;需要的角色名&quot;</span>);<br>    http.formLogin();<span class="hljs-comment">//启用框架自带登录页面</span><br>&#125;<br></code></pre></td></tr></table></figure>即配置了那些页面请求需要登录，并在没登录的时候跳转到一个登录界面。</li><li>配置角色<br>内存中用户角色：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.inMemoryAuthentication()<br>    .withUser(<span class="hljs-string">&quot;username&quot;</span>)<br>    .password(<span class="hljs-string">&quot;114514&quot;</span>)<br>    .roles(<span class="hljs-string">&quot;private_user&quot;</span>);<span class="hljs-comment">//.and()....</span><br>&#125;<br></code></pre></td></tr></table></figure>密码编码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">.passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">xxxPasswordEncoder</span>())<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Spring</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFmpeg备忘笔记</title>
    <link href="/2021/FFmpeg%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/FFmpeg%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Linux直接通过包管理器安装，Windows则在官网下载二进制文件并添加到PATH即可使用ffmpeg。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>FFmpeg可以自动识别输入和输出的格式（通过后缀名或读取信息），并进行简单的转换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-i 表示后面紧跟一个输入</span><br>ffmpeg -i from_video.mp4 to_video.avi<br></code></pre></td></tr></table></figure><p>如果想要指定转换使用的编码器，码率等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -i from.avi -c:v libx264 -b:v 1000k out.mp4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令输入一个avi文件，使用libx264编码器编码视频，音频流让ffmpeg自行处理，且视频码率设置为1000kbps，输出到out.mp4。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里原视频里的音频流一般会被压缩，也会被自动转换为MP4支持的格式。</span><br></code></pre></td></tr></table></figure><p>如果想要使用硬件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -hwaccel cuvid -c:v h264_cuvid -i input.xx -c:v h264_nvenc -preset slow output.xx <br></code></pre></td></tr></table></figure><p>更多高级参数建议看官方文档！</p><h1 id="一图流视频生成"><a href="#一图流视频生成" class="headerlink" title="一图流视频生成"></a>一图流视频生成</h1><h2 id="Step-1-生成静帧视频"><a href="#Step-1-生成静帧视频" class="headerlink" title="Step 1 生成静帧视频"></a>Step 1 生成静帧视频</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -loop 1 -r &lt;每秒帧数&gt; -t &lt;音频秒数/分号间隔时长&gt; -f image2 -i &lt;静帧图片路径&gt; -c:v libx264 -crf 30 -y SinglePictureVideo.mp4<br></code></pre></td></tr></table></figure><blockquote><p>获取音频的秒数可以直接<code>ffmpeg -i &lt;音频文件&gt;</code>，输出的信息里面的带有长度</p></blockquote><h2 id="Step-2-将静帧视频与音频合并"><a href="#Step-2-将静帧视频与音频合并" class="headerlink" title="Step 2 将静帧视频与音频合并"></a>Step 2 将静帧视频与音频合并</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -i SinglePictureVideo.mp4 -i &lt;音频文件&gt; -c:v copy -c:a copy -y &lt;输出文件&gt;.flv<br></code></pre></td></tr></table></figure><blockquote><p>FLV仅支持ACC与MP3音频</p></blockquote><h1 id="提取音频、视频流"><a href="#提取音频、视频流" class="headerlink" title="提取音频、视频流"></a>提取音频、视频流</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ffmpeg -i Source.mp4 -vn -codec copy out.xxx<br></code></pre></td></tr></table></figure><p><code>-vn</code>：屏蔽视频流，达到提取音频流效果。换为<code>-an</code>即可变为提取视频流。</p><p><code>-codec copy</code>：直接复制流，不转码。</p><p>请小心最后的输出格式。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FFmpeg</tag>
      
      <tag>视频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux(Debian)服务器使用Docker简单搭建WordPress服务器</title>
    <link href="/2021/Linux-Debian-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8Docker%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BAWordPress%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2021/Linux-Debian-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8Docker%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BAWordPress%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>Docker可以简化WordPress的部署过程，不需要自己安装phpMyAdmin，也不需要自己配置MySQL数据库。</p><p>仅简单的、基本的安装，诸如HTTPS配置、SSL证书配置等没有涉及（我也没有机会涉及）。</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>不清楚包管理工具是否有正常的Docker可以安装，Debian中APT的Docker不到100KB，看起来并不能用。因此，采用菜鸟教程提供的方法：</p><p>使用官方安装脚本自动安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br></code></pre></td></tr></table></figure><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl -sSL https://get.daocloud.io/docker | sh<br></code></pre></td></tr></table></figure><h2 id="下载Docker镜像"><a href="#下载Docker镜像" class="headerlink" title="下载Docker镜像"></a>下载Docker镜像</h2><p>使用docker pull拉取WordPress和MySQL镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker pull wordpress<br>docker pull mysql<br><span class="hljs-comment">#应该并不需要:latest</span><br><span class="hljs-comment">#如docker pull wordpress:latest</span><br></code></pre></td></tr></table></figure><p>如果你要安装特定版本，则名字改为wordpress:版本号。</p><h2 id="创建一个网络（两容器可互相访问的空间）"><a href="#创建一个网络（两容器可互相访问的空间）" class="headerlink" title="创建一个网络（两容器可互相访问的空间）"></a>创建一个网络（两容器可互相访问的空间）</h2><p>使用–link链接WordPress和MySQL两个容器的方法已经过时，并且不久的将来会弃用，因此使用docker network网络。</p><p>创建一个名为wp-net的网络，后续运行容器加入这个网络中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker network create wp-net<br></code></pre></td></tr></table></figure><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><h4 id="首先是运行MySQL："><a href="#首先是运行MySQL：" class="headerlink" title="首先是运行MySQL："></a>首先是运行MySQL：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name mysql --network wp-net --network-alias db -e MYSQL_ROOT_PASSWORD=你的密码 -d mysql<br></code></pre></td></tr></table></figure><blockquote><p>–name：把这个容器命名为mysql<br>–network：让这个容器加入名为wp-net的网络（重要）<br>–network-alias：为这个容器创建别名db，理解为后面用这个名字代表数据库的地址（重要）<br>–e：为设置环境变量，MYSQL_ROOT_PASSWORD指定MySQL中root用户的密码，经测试不指定无法正常启动容器。<br>-d：后台运行</p></blockquote><p>最后的mysql为镜像的名称，如果你要使用特定版本，则写为 mysql:5.1 即可。</p><h4 id="然后是运行WordPress："><a href="#然后是运行WordPress：" class="headerlink" title="然后是运行WordPress："></a>然后是运行WordPress：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker run --name wp --network wp-net -p 80:80 -d wordpress<br></code></pre></td></tr></table></figure><p>部分参数同上一步，一定要加入MySQL所在的网络，否则无法访问。</p><blockquote><p>-p：将容器内的端口映射到宿主机上，像虚拟机的端口转发，像路由器的端口绑定。这里是把容器内的80端口（冒号后面）映射到主机的80端口（冒号前面）。</p></blockquote><h2 id="配置安装WordPress"><a href="#配置安装WordPress" class="headerlink" title="配置安装WordPress"></a>配置安装WordPress</h2><p>在浏览器中进入你的网站进行配置，直到数据库配置页。</p><p>你可能（至少我是）需要在MySQL中创建一个数据库，和WordPress的数据库名相同。</p><p>数据库的用户名注意为root，因为Docker创建的时候默认为root，除非你自己设定了其他名字。</p><p>数据库的地址（默认为localhost），为改为Docker运行MySQL时设定的–network-alias，我这里为db，除非你使用外部数据库。</p><h2 id="MySQL新建数据库"><a href="#MySQL新建数据库" class="headerlink" title="MySQL新建数据库"></a>MySQL新建数据库</h2><p>你可能会遇到WordPress报能够连接到数据库但数据库不存在的问题，正如我。</p><p>进入MySQL容器：（注意容器的名字）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it mysql /bin/bash<br></code></pre></td></tr></table></figure><p> 打开数据库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mysql -u root -p<br></code></pre></td></tr></table></figure><p>创建数据库：（自己决定数据库名称）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">create database wordpress;<br></code></pre></td></tr></table></figure><p>最后，quit退出MySQL环境，exit退出容器。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>作者并不熟悉Docker，只是记录一下WordPress的配置方法以备忘，很多Docker的术语可能不正确。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>服务器</tag>
      
      <tag>Docker</tag>
      
      <tag>WordPress</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>关于</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p><a href="https://c6.y.qq.com/base/fcgi-bin/u?__=CoObXCxrca4h">Дорогой Человек - PERMSKY KRAY</a></p><p><a href="https://c6.y.qq.com/base/fcgi-bin/u?__=PjNE8n46">Bipolarity - Chef Tothor &#x2F; Supire</a></p><p><img src="/images/question.png"></p>]]></content>
    
  </entry>
  
  
  
</search>
